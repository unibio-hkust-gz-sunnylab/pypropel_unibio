{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>PyPropel provides a Python interface to better pre-processing protein data and post-processing.</p> <ul> <li> <p>pre-processing: interaction sites, protein datasets, protein features, etc.</p> </li> <li> <p>post-processing: statistics plot, evaluation, protein functional classes, etc.</p> </li> </ul> <p>You only need one line to use PyPropel in Python.</p> <pre><code>import pypropel as pp\n</code></pre>"},{"location":"#welcome_to_the_pypropel_documentation","title":"Welcome to the PyPropel documentation\ud83d\ude80.","text":""},{"location":"#features","title":"Features","text":"<p>Features</p> <ul> <li> Protein<ul> <li> Alignment</li> <li> Sequence</li> <li> Structre</li> </ul> </li> <li> Technical<ul> <li> PyPI</li> <li> Conda</li> <li> Docker</li> <li> Github</li> </ul> </li> <li> Unique module<ul> <li> Feature engineering</li> <li> One-stop dataset generation</li> </ul> </li> </ul>"},{"location":"about/","title":"About","text":"<p>Data pre-processing plays a key role in accelerating biological research. We are aiming to build a suite of software for better pre-processing biological data.</p>"},{"location":"change-log/","title":"Change log","text":""},{"location":"change-log/#change_log","title":"Change Log","text":""},{"location":"change-log/#unio_fork_extensions","title":"UniO Fork Extensions","text":"<p>[Jan. 19th 2026: pypropel_unibio fork]</p> <ul> <li>pypropel.mol: New module for ligand loading (SDF/MOL2), coordinates, features</li> <li>pypropel.str: Added <code>load_pdb()</code>, <code>read_pdb_sequence()</code>, <code>structure_to_sequence()</code></li> <li>pypropel.fpsite: Added residue features (<code>residue_one_hot</code>, <code>residue_physchem</code>, <code>residue_coords</code>)</li> <li>pypropel.fpsite: Added AA validation (<code>is_standard_aa</code>, <code>is_standard_aa_name</code>)</li> <li>pypropel.fpsite: Added window functions (<code>get_residue_window</code>, <code>get_residue_window_padded</code>)</li> <li>pypropel.fpsite: Added spatial neighbors (<code>get_spatial_neighbors</code>, <code>get_spatial_neighbor_indices</code>)</li> <li>pypropel.fpsite: Added positional encoding (<code>positional_encoding</code>, <code>batch_positional_encoding</code>, <code>relative_position</code>)</li> <li>pypropel.dist: Added <code>ContactMap</code> class with distance and contact map functions</li> <li>pypropel.dist: Added <code>extract_binding_pocket()</code> for binding site classification</li> <li>CI/CD: Added <code>tests.yml</code> and <code>lint.yml</code> workflows (43 tests passing)</li> </ul>"},{"location":"change-log/#original_pypropel","title":"Original PyPropel","text":"<p>[Dec. 8th 2024: version = \"0.1.3\"] adding extracting from UniProt fasta sequences to single sequences according to species. [Jul. 3th 2025: version = \"0.1.5\"] making function pypropel_struct_check_cplx [Jul. 7th 2025: version = \"0.1.6\"] making function pypropel_struct_dist_cplx1 [Jul. 20th 2025: version = \"0.1.7\"] harmonising label header protocols 2021 and 2025</p> <pre><code>1. tutorial/protein/convert/\n</code></pre>"},{"location":"contact/","title":"Contact","text":"<ul> <li> Developer: Jianfeng Sun</li> <li> Affiliation: Nuffield Department of Orthopaedics, Rheumatology and Musculoskeletal Sciences (NDORMS), Headington, Oxford OX3 7LD, University of Oxford.</li> <li> Email: Jianfeng.sun@ndorms.ox.ac.uk | Jianfeng.sunmt@gmail.com</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#system_requirement","title":"System Requirement","text":"<p>There is no requirement for PyPropel, a cross-platform package.</p>"},{"location":"installation/#pypi","title":"PyPI","text":"<p>pypropel homepage on PyPI</p> <pre><code># create a conda environment\nconda create --name pypropel python=3.11\n\n# activate the conda environment\nconda activate pypropel\n\n# the latest version\npip install pypropel --upgrade\n</code></pre>"},{"location":"installation/#conda","title":"Conda","text":"<p>pypropel homepage on Anaconda</p> <pre><code># create a conda environment\nconda create --name pypropel python=3.11\n\n# activate the conda environment\nconda activate pypropel\n\n# the latest version\nconda install jianfeng_sun::pypropel\n</code></pre>"},{"location":"installation/#docker","title":"Docker","text":"<p>pypropel homepage on Docker</p> <pre><code>docker pull 2003100127/pypropel\n</code></pre>"},{"location":"installation/#github","title":"Github","text":"<p>pypropel homepage on Github</p> <pre><code># create a conda environment\nconda create --name pypropel python=3.11\n\n# activate the conda environment\nconda activate pypropel\n\n# create a folder\nmkdir project\n\n# go to the folder\ncd project\n\n# fetch PyPropel repository with the latest version\ngit clone https://github.com/2003100127/pypropel.git\n\n# enter this repository\ncd pypropel\n\n# do the following command\npip install .\n# or\npython setup.py install\n</code></pre>"},{"location":"unibio-extensions/","title":"Unibio extensions","text":""},{"location":"unibio-extensions/#unio_modifications","title":"UniO Modifications","text":"<p>This fork (<code>pypropel_unibio</code>) extends the original pypropel with additional features for protein-ligand interaction analysis and GVP-Fusion model support.</p>"},{"location":"unibio-extensions/#new_modules","title":"New Modules","text":""},{"location":"unibio-extensions/#pypropelmol_-_small_molecule_utilities","title":"<code>pypropel.mol</code> - Small Molecule Utilities","text":"<pre><code>import pypropel.mol as ppmol\n\n# Load ligands\nmol = ppmol.load_sdf(\"/path/to/ligand.sdf\")\nmol = ppmol.load_mol2(\"/path/to/ligand.mol2\")\n\n# Extract coordinates\ncoords = ppmol.ligand_coords(mol)  # Shape: (N_atoms, 3)\n\n# Get global ligand features [LogP, MolWt, H-Donors, H-Acceptors]\nfeatures = ppmol.get_ligand_features(mol)  # Shape: (4,)\n\n# Atom-level features for GIN encoder\natom_types = ppmol.get_atom_type_onehot(mol)      # Shape: (N, 10)\nhybrid = ppmol.get_atom_hybridization(mol)        # Shape: (N, 7)\nhbond = ppmol.get_atom_hbond_features(mol)        # Shape: (N, 2)\naromatic = ppmol.get_atom_aromaticity(mol)        # Shape: (N, 1)\ncharges = ppmol.get_atom_partial_charges(mol)     # Shape: (N, 1) Gasteiger\natom_features = ppmol.get_atom_features(mol)      # Shape: (N, 21) Combined\n\n# Morgan fingerprints\nfp = ppmol.get_morgan_fingerprint(mol, radius=2, n_bits=2048)\nfp_compressed = ppmol.get_morgan_fingerprint_compressed(mol, output_dim=128)\n\n# Extended global features (basic + compressed Morgan FP)\nglobal_features = ppmol.get_ligand_global_features(mol)  # Shape: (132,)\n</code></pre>"},{"location":"unibio-extensions/#pypropelgvp_-_gvp_vector_features","title":"<code>pypropel.gvp</code> - GVP Vector Features","text":"<pre><code>import pypropel.gvp as ppgvp\n\n# Extract coordinates\nca_coords = ppgvp.get_ca_coords(structure)    # Shape: (N, 3)\ncb_coords = ppgvp.get_cb_coords(structure)    # Shape: (N, 3) (virtual for GLY)\n\n# Vector features for GVP encoder (4 vectors)\nsidechain = ppgvp.get_residue_orientations(structure)      # C\u03b1\u2192C\u03b2 unit vectors\nforward = ppgvp.get_backbone_vectors(structure)            # C\u03b1[i]\u2192C\u03b1[i+1]\nbackward = ppgvp.get_backward_vectors(structure)           # C\u03b1[i]\u2192C\u03b1[i-1]\nneighbors = ppgvp.get_neighbor_center_vectors(structure, k=10)  # C\u03b1\u2192neighbor center\n\n# Combined GVP features (4 vectors per residue)\ncoords, vectors = ppgvp.get_gvp_node_features(structure, k_neighbors=10)\n# coords: (N, 3), vectors: (N, 4, 3) - 4 unit vectors per residue\n\n# k-NN graph edges\nedge_index, distances = ppgvp.build_knn_edges(coords, k=20, radius=10.0)\n</code></pre>"},{"location":"unibio-extensions/#pypropelgraph_-_graph_construction","title":"<code>pypropel.graph</code> - Graph Construction","text":"<pre><code>import pypropel.graph as ppgraph\n\n# Build protein k-NN graph\ngraph = ppgraph.build_protein_knn_graph(structure, k=20, radius=10.0)\n# Returns: {'node_coords': (N,3), 'edge_index': (2,E), 'edge_attr': (E,4)}\n\n# Build ligand molecular graph\nligand_graph = ppgraph.build_ligand_graph(mol)\n# Returns: {'node_features': (N,21), 'node_coords': (N,3), \n#           'edge_index': (2,E), 'edge_attr': (E,4)}\n\n# Bond features for edges\nbond_features = ppgraph.get_bond_features(mol)  # One-hot bond types\n\n# Cross-modal bipartite edges (for attention)\nedges, dists = ppgraph.build_protein_ligand_bipartite_edges(\n    protein_coords, ligand_coords, threshold=8.0\n)\n</code></pre>"},{"location":"unibio-extensions/#pypropelesm_-_esm-2_embeddings_requires_fair-esm","title":"<code>pypropel.esm</code> - ESM-2 Embeddings (Requires <code>fair-esm</code>)","text":"<pre><code>import pypropel.esm as ppesm\n\n# Load model\nmodel, alphabet, converter = ppesm.load_esm_model(\"esm2_t33_650M_UR50D\")\n\n# Extract embeddings\nembeddings = ppesm.get_esm_embeddings(sequence)  # Shape: (L, 1280)\n\n# Batch extraction\nembeddings_list = ppesm.get_esm_embeddings_batch(sequences, batch_size=8)\n\n# Save/load cached embeddings\nppesm.save_embeddings(embeddings, \"/path/to/cache.npz\")\nembeddings = ppesm.load_embeddings(\"/path/to/cache.npz\")\n</code></pre>"},{"location":"unibio-extensions/#extended_pypropelstr_-_structure_utilities","title":"Extended <code>pypropel.str</code> - Structure Utilities","text":"<pre><code>import pypropel.str as ppstr\n\n# Load PDB structure\nstructure = ppstr.load_pdb(\"/path/to/protein.pdb\")\n\n# Extract sequence\nseq = ppstr.read_pdb_sequence(\"/path/to/protein.pdb\")\nseq = ppstr.structure_to_sequence(structure)\n</code></pre>"},{"location":"unibio-extensions/#extended_pypropelfpsite_-_residue_features","title":"Extended <code>pypropel.fpsite</code> - Residue Features","text":""},{"location":"unibio-extensions/#sasa_secondary_structure_via_dssp","title":"SASA &amp; Secondary Structure (via DSSP)","text":"<pre><code>import pypropel.fpsite as fpsite\n\n# Secondary structure one-hot (Helix/Sheet/Coil)\nss_onehot = fpsite.residue_secondary_structure('H')  # [1, 0, 0]\n\n# SASA per residue\nsasa_data = fpsite.get_residue_sasa(structure)  # List of dicts\nsasa_array = fpsite.get_structure_sasa(structure)  # Shape: (N,)\n\n# Secondary structure per residue\nss_array = fpsite.get_structure_ss(structure)  # Shape: (N, 3)\n\n# Combined DSSP features\nfeatures = fpsite.get_structure_features_dssp(structure)\n# Returns: {'sasa': (N,1), 'ss_onehot': (N,3), 'res_ids': (N,)}\n</code></pre>"},{"location":"unibio-extensions/#other_features","title":"Other Features","text":"<pre><code># One-hot encoding (20 dimensions)\none_hot = fpsite.residue_one_hot(\"ALA\")  # Shape: (20,)\n\n# Physicochemical properties [charge, hydrophobicity]\nphyschem = fpsite.residue_physchem(\"ARG\")  # [1.0, -1.0]\n\n# Spatial k-NN neighbors\nneighbors = fpsite.get_spatial_neighbors(structure, target_residue, k=5)\nindices = fpsite.get_spatial_neighbor_indices(structure, target_idx=10, k=5)\n\n# Positional encoding for transformers\npe = fpsite.positional_encoding(pos=5, max_len=100, dim=64)\nencodings = fpsite.batch_positional_encoding(seq_length=100, dim=64)\n</code></pre>"},{"location":"unibio-extensions/#extended_pypropeldist_-_distance_classification","title":"Extended <code>pypropel.dist</code> - Distance &amp; Classification","text":"<pre><code>import pypropel.dist as ppdist\n\n# Existing distance functions\ndist = ppdist.residue_ligand_distance(residue_coords, ligand_coords)\ndistances = ppdist.protein_ligand_distances(structure, ligand_coords)\ncontact_map = ppdist.protein_contact_map(structure, threshold=8.0)\n\n# NEW: Distance classification for training labels\nlabel = ppdist.classify_binding_distance(distance, thresholds=[3.5, 6.0])\n# Returns 0 (Contact &lt;3.5\u00c5), 1 (Near &lt;6.0\u00c5), 2 (Far)\n\n# Per-residue labels\nlabels = ppdist.get_distance_labels(structure, ligand_coords, thresholds=[3.5, 6.0])\n# Shape: (N_residues,)\n\n# With residue info\ndf = ppdist.get_distance_labels_with_info(structure, ligand_coords)\n# DataFrame: chain, res_id, res_name, distance, label\n\n# Class weights for Focal Loss\nweights = ppdist.get_class_weights(labels)  # Inverse frequency weights\n\n# Binding pocket extraction\npocket_df = ppdist.extract_binding_pocket(\n    structure, ligand_coords,\n    binding_threshold=5.0, non_binding_threshold=8.0\n)\n</code></pre>"},{"location":"unibio-extensions/#pypropelfeatures_-_unified_feature_extraction_new","title":"<code>pypropel.features</code> - Unified Feature Extraction (NEW)","text":"<p>Configurable, general-purpose feature extraction functions:</p> <pre><code>import pypropel.features as ppfeat\n\n# List available feature classes\nprint(ppfeat.list_feature_classes('protein'))\n# {'onehot': 20, 'ss': 3, 'sasa': 1, 'charge': 1, ...}\n\nprint(ppfeat.list_feature_classes('ligand'))\n# {'atom_type': 10, 'hybridization': 4, 'aromaticity': 1, ...}\n\n# Protein features - configurable\nfeatures = ppfeat.get_protein_features(\n    structure,\n    feature_classes=['onehot', 'ss', 'sasa', 'charge', 'hydrophobicity'],\n    include_gvp=True,      # Include GVP vector features\n    use_dssp=True          # Use DSSP for SS and SASA\n)\n# Returns: {\n#   'scalar_features': (N, 26) - Combined scalar features\n#   'gvp_coords': (N, 3) - C\u03b1 coordinates  \n#   'gvp_vectors': (N, 4, 3) - 4 GVP vectors\n#   'feature_dims': {'onehot': (0, 20), 'ss': (20, 23), ...}\n# }\n\n# Ligand features - configurable\nfeatures = ppfeat.get_ligand_features(\n    mol,\n    include_global_tag=True,  # Append global FP to each atom\n    global_tag_dim=45\n)\n# Returns: {\n#   'atom_features': (M, 64) - Combined atom features\n#   'coords': (M, 3) - Atom coordinates\n#   'feature_dims': {'atom_type': (0, 10), ...}\n# }\n\n# Binding labels - configurable thresholds\nlabels = ppfeat.get_binding_labels(\n    structure, ligand_coords,\n    thresholds=[3.5, 6.0]  # 3-class: Contact/Near/Far\n)\n# Returns: {'labels': (N,), 'distances': (N,), 'class_weights': (3,)}\n</code></pre>"},{"location":"unibio-extensions/#extended_atom_features_64-dim","title":"Extended Atom Features (64-dim)","text":"<pre><code>import pypropel.mol as ppmol\n\n# Extended atom features for GVP-Fusion v2 (64 dimensions)\natom_features = ppmol.get_atom_features_extended(mol, global_tag_dim=45)\n# Shape: (N_atoms, 64)\n# Breakdown:\n#   [0-9]   Atom type one-hot (10): C, N, O, S, F, P, Cl, Br, I, Other\n#   [10-13] Hybridization (4): SP, SP2, SP3, Aromatic\n#   [14]    Aromaticity (1): Binary\n#   [15]    Is_Donor (1): Binary\n#   [16]    Is_Acceptor (1): Binary\n#   [17]    Gasteiger Charge (1): Float\n#   [18]    Ring Size (1): Integer (0 if not in ring)\n#   [19-63] Global Tag (45): Morgan FP + LogP + TPSA\n\n# Ring size per atom\nring_sizes = ppmol.get_atom_ring_sizes(mol)  # Shape: (N, 1)\n\n# Global tag (molecular fingerprint for each atom)\nglobal_tag = ppmol.get_global_tag(mol, output_dim=45)  # Shape: (45,)\n</code></pre>"},{"location":"unibio-extensions/#protein_scalar_features_35-dim","title":"Protein Scalar Features (35-dim)","text":"<pre><code>import pypropel.fpsite as fpsite\n\n# Full scalar features for GVP-Fusion v2 (35 dimensions)\nfeatures = fpsite.get_protein_scalar_features(structure, use_dssp=True)\n# Shape: (N_residues, 35)\n# Breakdown:\n#   [0-19]  AA one-hot (20)\n#   [20-22] Secondary structure one-hot (3): Helix/Sheet/Coil\n#   [23]    SASA normalized (1)\n#   [24]    Charge (1)\n#   [25]    Hydrophobicity normalized (1)\n#   [26]    Is_Aromatic (1): Phe/Tyr/Trp/His\n#   [27]    H-Bond Donor count (1)\n#   [28]    H-Bond Acceptor count (1)\n#   [29-34] Reserved/padding (6)\n</code></pre>"},{"location":"unibio-extensions/#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/unibio-hkust-gz-sunnylab/pypropel_unibio.git\n\n# For ESM embeddings (optional)\npip install fair-esm\n</code></pre>"},{"location":"unibio-extensions/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.9</li> <li>BioPython &gt;= 1.81</li> <li>RDKit &gt;= 2023.0.0</li> <li>NumPy &gt;= 1.24.0</li> <li>Pandas &gt;= 2.0.0</li> <li>fair-esm (optional, for ESM-2 embeddings)</li> </ul>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/","title":"Pipeline 1 Interaction Site Prediction","text":"<p>We walk you through a detailed, hands-on tutorial in predicting interaction sites in transmembrane proteins using PyPropel in tandem with TMKit, an external tool specialising in sequence analysis of transmembrane proteins.</p> <p>You will specifically see how PyPropel and TMKit can batch pre-process the structures of 10,971 protein complexes files (including structures of 58,060 protein chains). Finally, we will put the generated data for machine learning using scikit-learn.</p> <p>It includes 5 modules:</p> <p>Features</p> <ul> <li> Pre-processing</li> <li> Feature extraction</li> <li> Machine learning with random forest</li> <li> Machine learning evaluation metrics</li> <li> Visualisation of evaluation metrics</li> </ul> <p>Let's first import both of the libraries.</p> <p> Python <pre><code>import pypropel as pp\nimport tmkit as tmk\n</code></pre></p> <p>Additionally, we will also use NumPy and Pandas for quickly processing data.</p> <p> Python <pre><code>import numpy as np\nimport pandas as pd\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#1_pre-processing","title":"1. Pre-processing","text":""},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#11_downloading_a_pdbtm_database","title":"1.1 Downloading a PDBTM database","text":"<p>Then, we can download an up-to-date list of transmembrane proteins  from the PDBTM database (version: <code>12.06.2024</code>). Here, we also attach other two lists (version: <code>06.30.2023</code> and <code>10.02.2023</code>), which were previously downloaded. The latest version of transmembrane proteins can be found here.</p> <p> Python <pre><code>pdb_fpn_dict = {\n    '06.30.2023': 'data/database/pdbtm_alpha_06.30.2023.txt',\n    '10.02.2023': 'data/database/pdbtm_alpha_10.02.2023.txt',\n    '12.06.2024': 'data/database/pdbtm_alpha_12.06.2024.txt',\n}\n</code></pre></p> <p>Check whether the latest list of proteins have been duplicated between one another due to technical errors. Then, save the deduplicated list of proteins (if you use version <code>12.06.2024</code> for example).</p> <p> Python <pre><code>df_latest = df_latest.drop_duplicates()\n\npp.io.write(\n    sv_fpn='data/database/pdbtm_alpha_12.06.2024.txt',\n    df=df_latest,\n    df_sep='\\t',\n    header=None,\n)\n</code></pre></p> <p>We read every two latest lists for getting the updated proteins.</p> <p> Python <pre><code>df_old = pp.io.read(\n    df_fpn=pdb_fpn_dict['06.30.2023'],\n    # df_fpn=pdb_fpn_dict['10.02.2023'],\n    # df_fpn=pdb_fpn_dict['12.06.2024'],\n    df_sep='\\t',\n    header=None,\n)\nprint(df_old)\n\ndf_latest = pp.io.read(\n    # df_fpn=pdb_fpn_dict['06.30.2023'],\n    # df_fpn=pdb_fpn_dict['10.02.2023'],\n    df_fpn=pdb_fpn_dict['12.06.2024'],\n    df_sep='\\t',\n    header=None,\n)\nprint(df_latest)\n</code></pre></p> <p>Find the portion of proteins updated in the latest version of PDBTM. Then, store it as <code>prot_series</code>.</p> <p> Python <pre><code>pds_diff, psd_rept = pp.io.list_diff_unipartite(\n    pds_lg=df_latest[0],\n    pds_sm=df_old[0],\n    # sv_diff_fpn='data/database/diff.txt',\n    # sv_rept_fpn='data/database/repeat.txt',\n    sv_diff_fpn=None,\n    sv_rept_fpn=None,\n)\nprint(pds_diff)\nprint(psd_rept)\n\ndf = pd.DataFrame()\ndf['prot'] = pds_diff.apply(lambda x: x[:4])\ndf['chain'] = pds_diff.apply(lambda x: x[-1:])\ndf['ij'] = df.apply(lambda x: x['prot'] + '.' + x['chain'], axis=1)\nprint(df)\nprot_series = pd.Series(df['prot'].unique())\nprint(prot_series)\n</code></pre></p> <p>Retrive PDBTM structures and store them in <code>data/pdbtm/cplx/</code>. As the protein structures are transposed from RCSB PDB files, it is necessary to denote <code>kind</code> as <code>tr</code>.</p> <p> Python <pre><code>tmk.seq.retrieve_pdb_from_pdbtm(\n    prot_series=prot_series,\n    kind='tr',\n    sv_fp='data/pdbtm/cplx/',\n)\n</code></pre></p> <p>Retrive PDBTM XML files (useful for getting topological information) and store them in <code>data/xml/</code>.</p> <p> Python <pre><code>tmk.seq.retrieve_xml_from_pdbtm(\n    prot_series=prot_series,\n    sv_fp='data/xml/',\n)\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#12_cleaning_structural_data","title":"1.2 Cleaning structural data","text":"<p>We can go on with how we extract the structure of each chain from a protein complex structure stored in PDB.</p> <p>There are two ways to get the list of chains with respect to their proteins.</p> <p>Option 1. Fetch all structures gathered accumulatively from updated list. This is because in each updated list, some proteins from previous lists go away yet have been downloaded. We need to include those that go away.</p> <p> Python <pre><code>df = pp.io.find_from_folder(\n    file_path='data/pdbtm/cplx/',\n    suffix='.pdb',\n    flag=1,\n    # sv_fpn=None,\n    sv_fpn='data/cplx.txt',\n)\nprint(df)\n</code></pre></p> <p>Then, we can use <code>pp.str.chains</code> to get all chains from the complex structure of each protein. After then, we save the list.</p> <pre><code>a = []\nfor i in df.index:\n    try:\n        chains = pp.str.chains(\n            pdb_fp='data/pdbtm/cplx/',\n            pdb_name=df[0][i],\n        )\n        print(i, df[0][i], chains)\n        for j in chains:\n            a.append([df[0][i], j])\n    except:\n        continue\npp.io.write(\n    df=pd.DataFrame(a),\n    sv_fpn='data/database/pdbtm_alpha_accumulated.txt',\n    df_sep='\\t',\n)\ndf = pp.io.read(\n    df_fpn='data/database/pdbtm_alpha_accumulated.txt',\n    df_sep='\\t',\n    header=None,\n).rename(columns={0: 'prot', 1: 'chain'})\nprint(df)\n</code></pre> <p>Option 2. Get chains from all previously gathered lists of proteins by getting the union of all of them. We can do like this. </p> <p>Warning</p> <p>Make sure each time we have two headers <code>prot</code> and <code>chain</code> in the dataframe (<code>df</code>) for indicating proteins and chains. Because other functions might need this information as required.</p> <p> Python <pre><code>df = pd.concat([pp.io.read(i) for i in [*pdb_fpn_dict.values()]]).drop_duplicates().reset_index(drop=True)\ndf['prot'] = pds_diff.apply(lambda x: x[:4])\ndf['chain'] = pds_diff.apply(lambda x: x[-1:])\nprint(df)\n</code></pre></p> <p>Then, use the <code>pp.dataset.download_pack</code> function to extract the structures of all chains from the structures of all protein complexes. To this end, we need to specify where complexes are located (e.g. <code>data/pdbtm/cplx/</code>) and where structures of all chains are to be stored (e.g. <code>data/pdb/</code>).</p> <p>Note</p> <p>Please note that <code>pp.dataset.download_pack</code> will also refine the structures of all chains (see this page). It includes reformatting structures and removing <code>HETATM</code>. It will also tell you if the sequence of a protein chain stored in <code>XML</code> file is the same as it is in the PDB file. It will extract the sequence to be stored in the <code>FASTA</code> format.</p> <p> Python <pre><code>pp.dataset.download_pack(\n    prot_df=df,\n    pdb_cplx_fp='data/pdbtm/cplx/',\n    pdb_fp='data/pdb/',\n    xml_fp='data/xml/',\n    fasta_fp='data/fasta/',\n)\n</code></pre></p> <p>You will see the files as shown in the following screenshoots.</p> Fig. Split Fasta files per chain Fig. Downloaded XML files Fig. Split PDB files per chain"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#13_quality_control_of_data","title":"1.3 Quality control of data","text":"<p>After these files above are obtained, everything is all set before we exactly work on quality control (QC) of the sequence, topological, and structural data.</p> <p>We can use <code>tmk.qc.integrate</code> or <code>tmk.qc.obtain_single</code> to obtain the metrics that we can use to remove or retain protein chains for analysis.</p> <p>For simplicity, we showcase the generation of each metric based on a metric given. We are interested in <code>nchain</code>, <code>rez</code>, <code>met</code>, <code>mthm</code>, <code>seq</code>, corresponding to the numebr of chains in a protein complex, resolution, resolving experimental method, number of transmembrane helices, and amino acid sequences. Apart from these, we can also order the generation of something extra by using <code>bio_name</code>, <code>head</code>, and <code>desc</code> for how the protein is named biologically and what is the head of the PDB file, and general description of the protein strucuture.</p> <p> Python <pre><code>df_qc_sgl = tmk.qc.obtain_single(\n    df_prot=df_prot,\n    pdb_cplx_fp=to('data/ex/pdbtm/'),\n    fasta_fp=to('data/ex/fasta/'),\n    xml_fp=to('data/ex/xml/'),\n    sv_fp=to('data/ex/'),\n    metric='nchain',\n)\nprint(df_qc_sgl)\n\n# df_integ = tmk.qc.integrate(\n#     df_prot=df,\n#     pdb_cplx_fp='data/pdbtm/cplx/',\n#     fasta_fp='data/fasta/',\n#     xml_fp='data/xml/',\n#     sv_fp='data/qc/',\n#     metrics=[\n#         'nchain',\n#         # 'rez',\n#         # 'met',\n#         # 'mthm',\n#         # 'seq',\n#\n#         # 'bio_name', 'head', 'desc',\n#     ],\n# )\n# print(df_integ)\n</code></pre></p> <p>Then, you will see</p> Fig. Files of QC metrics <p>Then, we can do a separate coding procedure for integrating these metrics together within a single file by using the following codes.</p> <p> Python <pre><code>qc_fpn_dict = {\n    'met': 'data/qc/wb_met_c.txt',\n    'mthm': 'data/qc/wb_mthm_c.txt',\n    'nchain': 'data/qc/wb_nchain_c.txt',\n    'rez': 'data/qc/wb_rez_c.txt',\n    'bio_name': 'data/qc/wb_bio_name_c.txt',\n}\ndf = pp.io.read(\n    df_fpn='data/qc/wb_seq_c.txt',\n    df_sep='\\t',\n    header=None,\n).rename(\n    columns={\n        0: 'prot',\n        1: 'chain',\n        2: 'prot_mark',\n        3: 'seq',\n        4: 'len_seq',\n    }\n)\nprint(df)\nfor metric, fpn in qc_fpn_dict.items():\n    df[metric] = pp.io.read(\n        df_fpn=fpn,\n    )[3]\nprint(df)\npp.io.write(\n    df=df,\n    sv_fpn='data/qc/integrate.xlsx',\n    header=True,\n    kind='excel',\n)\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#14_integrtation_of_qc_metrics","title":"1.4 Integrtation of QC metrics","text":"Fig. vignette of integrtated QC metrics <p>But you should see the problem now, for metrics <code>met</code> and <code>nchain</code>, blanks remain not filled out. This is because, we generate them at the protein complex level rather than protein chain level. But within the metric file, proteins are rendered at the protein chain levels. Thus, we need to step up the fill of the two metrics in the table. We can make it by</p> <p> Python <pre><code>df = pp.io.read(\n    df_fpn='data/qc/integrate.xlsx',\n    sheet_name='Sheet1',\n    header=0,\n    kind='excel',\n)\nprint(df)\ndf_ = df.dropna(subset=['met'])[['prot', 'met']]\ndf_nchain = pd.read_csv(\n    'data/qc/wb_nchain_c.txt',\n    header=None,\n    sep='\\t',\n).dropna()\nnchain_map = pd.Series(df_nchain[3].values, index=df_nchain[0]).to_dict()\nmet_map = pd.Series(df_['met'].values, index=df_['prot']).to_dict()\n# print(met_map)\n# print(nchain_map)\nmet_keys = [*met_map.keys()]\nnchain_keys = [*nchain_map.keys()]\nimport numpy as np\ndf['nchain'] = df['prot'].apply(lambda x: nchain_map[x] if x in nchain_keys else np.nan)\ndf['met1'] = df['prot'].apply(lambda x: met_map[x] if x in met_keys else np.nan)\nprint(df.prot.unique().shape[0])\ndf.to_excel('data/qc/integrate1.xlsx',)\n</code></pre></p> <p>This results in a file called <code>integrate1.xlsx</code>. We can see the blanks have all been filled out for the two metrics.</p> Fig. Stepping up the fill area of `met` and `nchain`"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#15_generating_datasets","title":"1.5 Generating datasets","text":"<p>Next, we can screen protein chains by setting restrictions, thus generating a dataset.</p> <p> Python <pre><code>df = pp.io.read(\n    'data/qc/integrate1.xlsx',\n    sheet_name='Sheet1',\n    header=0,\n    kind='excel',\n)\nprint(df)\nprint(df.columns)\ndf = df.loc[\n    (df['rez'] &lt; 3.5)\n    &amp; (df['mthm'] &gt;= 2)\n    # &amp; (df['len_seq'] &gt;= 100)\n    &amp; (df['len_seq'] &lt; 1000)\n    &amp; (df['met1'] == 'x-ray diffraction')\n    &amp; (df['nchain'] &gt;= 2)\n]\nprint(df.shape[0])\nprint(df.prot.unique().shape[0])\nprint(df)\npp.io.write(\n    df=df,\n    sv_fpn='data/qc/dataset.xlsx',\n    df_sep='\\t',\n    header=True,\n    kind='excel',\n)\n</code></pre></p> <p>This results in a dataset of 7148 protein chains screened for use.</p> Fig. Dataset <p>For all of these protein complexes with at least two protein chains, we need to calculate if protein chains within the complexes are spatially and physically in interaction. This information will be treated as the labels of each protein site. We can achieve this with two ways. We can rekcon two protein chains as being in interaction if their distance is within an angstrom (\u00c5) of 5.5.</p> <ol> <li>Batch processing them on cloud. </li> </ol> <p> Python <pre><code>df = pfreader().generic(df_fpn=to('data/qc/dataset.xlsx'), header=0)\nprots = df.prot.unique()\n\nparam_config = {\n    'pdb_fp': '-fp',\n    'pdb_fn': '-fn',\n    'sv_fp': '-op',\n}\nvalue_config = {\n    'tool_fp': '/path/to/your/conda environment/python',\n    'script_fpn': './Complex.py',\n    'pdb_fp': '/path/to/protein complex files/',\n    'sv_fp': '/path/to/save/results/',\n}\n\nfor key, prot in enumerate(prots):\n    order_list = [\n        value_config['tool_fp'],\n        value_config['script_fpn'],\n\n        param_config['pdb_fp'], value_config['pdb_fp'],\n        param_config['pdb_fn'], prot,\n        param_config['sv_fp'], value_config['sv_fp'],\n    ]\n    pp.dist.cloud_check(\n        order_list=order_list,\n        job_fp='/path/to/save/job files/',\n        job_fn=str(key),\n        cpu=2,\n        memory=10,\n        method='script',\n        submission_method='sbatch',\n    )\n</code></pre></p> <ol> <li>(Recommend) Or, you can still generate all of them on your own computer by the following code. This might take long to take all. You can simply extract a small portion of these proteins for training purposes. Then, if you famililarise them, you could perform all of these operations on cloud.</li> </ol> <p> Python <pre><code>df = pp.io.read(df_fpn=to('data/qc/dataset.xlsx'), header=0, kind='excel')\nprots = df.prot.unique()\nfor key, prot in enumerate(prots):\n    pp.dist.check_chain_complex(\n        pdb_fp=to('data/pdb/complex/pdbtm/'),\n        prot_name='1aij',\n        sv_fp=to('data/pdb/complex/pdbtm/'),\n        thres=5.5,\n    )\n</code></pre></p> <p>This will result in a lot of text files per protein complex. </p> Fig. Files for checking if chains in a complex are in interaction <p>Then, we can merge them all as a <code>merge.txt</code> file for easily accessing the information.</p> <p> Python <pre><code>df = pp.io.find_from_folder(\n    file_path='data/ccheck/',\n    suffix='.ccheck',\n    flag=1,\n    sv_fpn=None,\n    # sv_fpn=to('data/find.txt'),\n)\nprint(df)\ndf_c = pd.DataFrame()\nfor i, file_i in enumerate(df[0].values):\n    try:\n        tt = pp.io.read(\n            df_fpn='data/ccheck/' + str(file_i) + '.ccheck',\n            df_sep='\\t',\n            header=None,\n        )\n        df_c = pd.concat([df_c, tt], axis=0).reset_index(drop=True)\n    except:\n        continue\nprint(df_c)\npp.io.write(\n    df=df_c,\n    sv_fpn='data/ccheck/merge.txt',\n    df_sep='\\t',\n)\n</code></pre></p> <p>After this, we can get the overlap of both the proteins screen from QC analysis and the proteins that are in interaction. We can do the following. Then save it as <code>dataset_post_ccheck.xlsx</code>.</p> <p> Python <pre><code>df_dataset = pp.io.read(\n    df_fpn='data/qc/dataset.xlsx',\n    df_sep='\\t',\n    header=0,\n    kind='excel',\n)\ndf_ccheck = pp.io.read(df_fpn='data/ccheck/merge.txt', header=None)\ndf_ccheck['prot_mark'] = df_ccheck.apply(lambda x: x[0] + x[1], axis=1)\nprint(df_ccheck)\ndf = df_dataset.merge(\n    df_ccheck,\n    on=['prot_mark'],\n)\nprint(df)\ndf = df.drop_duplicates(subset=['prot_mark'])\npp.io.write(\n    df=df,\n    sv_fpn='data/qc/dataset_post_ccheck.xlsx',\n    df_sep='\\t',\n    header=True,\n    kind='excel',\n)\nprint(df)\n</code></pre></p> Fig. Final dataset after confirming whether they are in interaction <p>Now, you have the dataset for machine learning!</p>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#2_feature_extraction","title":"2. Feature extraction","text":"<p>We can start feature extraction for these protein chains. But for better illustration, we only take two example protein chains, that is, protein <code>1xqf</code> chain <code>A</code> (for training a machine learning model) and protein <code>1aij</code> chain <code>L</code> (for testing the model).</p> <p>First, we can generate the label <code>y</code>.</p> <p>Calculate the distance first.</p> <p> Python <pre><code>pp.dist.complex_calc_all(\n    pdb_fp='data/pdbtm/cplx/',\n    prot_name='1aij',\n    prot_chain='L',\n    method='heavy',\n    sv_fp='data/dist/',\n)\npp.dist.complex_calc_all(\n    pdb_fp='data/pdbtm/cplx/',\n    prot_name='1xqf',\n    prot_chain='A',\n    method='heavy',\n    sv_fp='data/dist/',\n)\n</code></pre></p> Fig. Distance of amino acids in `1xqfA` <p>Labelling them according to the distance then.</p> <p> Python <pre><code>df_train = pp.dist.labelling(\n    dist_fp='data/dist/',\n    prot_name='1xqf',\n    file_chain='A',\n    cutoff=5.5,\n)\nprint(df_train)\ndf_test = pp.dist.labelling(\n    dist_fp='data/dist/',\n    prot_name='1aij',\n    file_chain='L',\n    cutoff=5.5,\n)\nprint(df_test)\n</code></pre></p> <p><code>is_contact</code> shows the label of each amino acid site.</p> <p> Output <pre><code>19/12/2024 15:58:15 logger: ================&gt;Labeling data...\n19/12/2024 15:58:15 logger: ================&gt;Time to label distances 1xqf A: 0.006977558135986328s.\n     fasta_id aa  pdb_id     dist_1     dist_2  is_contact\n0           1  A       3  11.391303  11.278594           0\n1           2  V       4   7.974939   9.416605           0\n2           3  A       5   7.700507   6.696266           0\n3           4  D       6   3.313506   5.633641           1\n4           5  K       7   6.614738   3.045629           1\n..        ... ..     ...        ...        ...         ...\n357       358  G     382  35.826157  13.476321           0\n358       359  L     383  32.409570  14.432422           0\n359       360  R     384  32.183815  14.324697           0\n360       361  V     385  28.519402  10.922935           0\n361       362  P     386  32.594830  10.024420           0\n\n[362 rows x 6 columns]\n19/12/2024 15:58:15 logger: ================&gt;Labeling data...\n19/12/2024 15:58:15 logger: ================&gt;Time to label distances 1aij L: 0.0030066967010498047s.\n     fasta_id aa  pdb_id    dist_1     dist_2  is_contact\n0           1  A       1  3.359507   3.820152           1\n1           2  L       2  4.832898   2.840869           1\n2           3  L       3  3.621853   3.450767           1\n3           4  S       4  6.046180   2.841488           1\n4           5  F       5  3.438960   3.688982           1\n..        ... ..     ...       ...        ...         ...\n276       277  G     277  2.910155  43.177975           1\n277       278  G     278  3.036153  40.448544           1\n278       279  I     279  2.979592  36.381110           1\n279       280  N     280  2.980944  38.922234           1\n280       281  G     281  3.484761  42.785560           1\n\n[281 rows x 6 columns]\n</code></pre></p> <p>To generate <code>X</code>, we extract features for the two proteins. But for demenstration here, we only involve amino acid properties in this process. There are 23 properties available to use, including</p> <p> Python <pre><code>property = [\n    \"positive\",\n    \"negative\",\n    \"charged\",\n    \"polar\",\n    \"aliphatic\",\n    \"aromatic\",\n    \"hydrophobic\",\n    \"small\",\n    \"active\",\n    \"weight\",\n    \"pI\",\n    \"solubility\",\n    \"tm\",\n    \"pka\",\n    \"pkb\",\n    \"hydrophilicity\",\n    \"hydrophobicity\",\n    \"fet\",\n    \"hydration\",\n    \"signal\",\n    \"volume\",\n    \"polarity\",\n    \"composition\",\n]\n</code></pre></p> <p>Then, we mainly use the <code>TMKit</code> tool to generate these features.</p> <p> Python <pre><code>seq_train = tmk.seq.read_from_fasta(\n    fasta_fpn='./data/fasta/1xqfA.fasta'\n)\n# print(seq_train)\nseq_test = tmk.seq.read_from_fasta(\n    fasta_fpn='./data/fasta/1aijL.fasta'\n)\n# print(seq_test)\npos_list_train = tmk.seq.pos_list_single(\n    len_seq=len(seq_train),\n    seq_sep_superior=None,\n    seq_sep_inferior=0,\n)\n# print(pos_list_train)\npos_list_test = tmk.seq.pos_list_single(\n    len_seq=len(seq_test),\n    seq_sep_superior=None,\n    seq_sep_inferior=0,\n)\n# print(pos_list_test)\n\npos_train = tmk.seq.pos_single(sequence=seq_train, pos_list=pos_list_train)\n# print(pos_train)\npos_test = tmk.seq.pos_single(sequence=seq_test, pos_list=pos_list_test)\n# print(pos_test)\n\nX_train = [[] for i in range(len(pos_train))]\nX_test = [[] for i in range(len(pos_test))]\n\nfor i, pos in enumerate(pos_train):\n    for prop in property:\n        X_train[i].append(pp.fpsite.property(prop_kind=prop)[pos[1]])\nfor i, pos in enumerate(pos_test):\n    for prop in property:\n        X_test[i].append(pp.fpsite.property(prop_kind=prop)[pos[1]])\n        # print(pos)\n</code></pre></p> <p>Let's now check <code>X</code> and <code>y</code></p> <p> Python <pre><code>import numpy as np\nX_train = np.array(X_train)\nX_test = np.array(X_test)\ny_train = df_train['is_contact'].values\ny_test = df_test['is_contact'].values\nprint(X_train)\nprint(X_test)\nprint(y_train)\nprint(y_test)\n</code></pre></p> <p> Output <pre><code>[[1.         1.         1.         ... 0.16766467 0.39506173 0.        ]\n [1.         1.         1.         ... 0.48502994 0.12345679 0.        ]\n [1.         1.         1.         ... 0.16766467 0.39506173 0.        ]\n ...\n [0.         1.         0.33333333 ... 0.7245509  0.69135802 0.23636364]\n [1.         1.         1.         ... 0.48502994 0.12345679 0.        ]\n [1.         1.         1.         ... 0.17664671 0.38271605 0.14181818]]\n[[1.         1.         1.         ... 0.16766467 0.39506173 0.        ]\n [1.         1.         1.         ... 0.64670659 0.         0.        ]\n [1.         1.         1.         ... 0.64670659 0.         0.        ]\n ...\n [1.         1.         1.         ... 0.64670659 0.03703704 0.        ]\n [1.         1.         1.         ... 0.31736527 0.82716049 0.48363636]\n [1.         1.         1.         ... 0.         0.50617284 0.26909091]]\n[0 0 0 1 1 1 1 1 1 1 0 ... 0 0 0 0 0 0 0 0]\n[1 1 1 1 1 1 1 1 1 1 1 ... 1 1 1 1 1 1 1 1]\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#3_machine_learning_with_random_forest","title":"3. Machine learning with random forest","text":"<p>Then, we can train a machine learning model by using random forest algorithms. We can draw upon the use of <code>sklearn</code> library.</p> <p> Python <pre><code>from sklearn.ensemble import RandomForestClassifier\nclf = RandomForestClassifier(n_estimators=100)\nclf.fit(X_train, y_train)\ny_pred = clf.predict(X_test)\n# print(y_pred)\ny_prob = clf.predict_proba(X_test)\nfrom sklearn import metrics\nprint(\"Accuracy:\", metrics.accuracy_score(y_test, y_pred))\n</code></pre></p> <p> Output <pre><code>Accuracy:  0.5765124555160143\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#4_machine_learning_evaluation_metrics","title":"4. Machine learning evaluation metrics","text":"<p>Before post-processing and post-analysing the machine learning data, we need to save the prediction probabilities in <code>tma300</code> formats, having 1st column as amino acid positions, 2nd column as amino acid symbols, and 3rd column as prediction probabilities. </p> <p> Python <pre><code>df = pd.DataFrame(pos_test)\ndf = df[[0, 1]]\ndf[2] = y_prob[:, 0].tolist()\npp.io.write(df=df, sv_fpn='data/isite/1aijL.tma300')\n</code></pre></p> <p>Then, batch generating comprehensive sets of evaluation metrics.</p> <p> Python <pre><code>pp.eval.sitewise_segment(\n    prot_df=pd.DataFrame({\n        'prot': ['1aij', ],\n        'chain': ['L', ],\n    }),\n    dist_fp='data/dist/',\n    dist_limit=5.5,\n    tool_fp='data/isite/',\n    tool='tma300',\n    pdb_fp='data/pdb/',\n    topo_fp='data/isite/',\n    xml_fp='data/xml/',\n    fasta_fp='data/fasta/',\n    segment='phobius_tmh',\n    sort=1,\n    sv_fp='data/isite/',\n)\n</code></pre></p> <p>Warning</p> <p>We made the evaluation in transmembrane areas predicted by Phobius. Then, we need to put this file in <code>topo_fp='data/isite/'</code>. This file can be downloaded from the PyPropel repository through the <code>release</code> tab.</p> <p>Then, we will see a lot of files of evaluation metrics there.</p> Fig. Files of evaluation metrics <p>The metrics are tabulated in JSON formats.</p> Fig. True positives"},{"location":"tutorial/Example/Pipeline-1-Interaction-Site-Prediction/#5_visualisation_of_evaluation_metrics","title":"5. Visualisation of evaluation metrics","text":"<p>Finally, we can plot the evaluation metrics using PyPropel. For example, the ROC curves.</p> <p> Python <pre><code>X_fpns = {\n    'tma300': 'data/isite/tma300_roc_fpr_custom.json',\n}\nY_fpns = {\n    'tma300': 'data/isite/tma300_roc_tpr_custom.json',\n}\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots(\n    nrows=2,\n    ncols=2,\n    # figsize=(6, 5),\n    figsize=(12, 10),\n    sharey='all',\n    sharex=False,\n)\npp.plot.rocpr(\n    X_fpns,\n    Y_fpns,\n    x_label='fpr',\n    y_label='tpr',\n    title='',\n    ax=ax[0, 0],\n)\npp.plot.rocpr(\n    X_fpns,\n    Y_fpns,\n    x_label='fpr',\n    y_label='tpr',\n    title='',\n    ax=ax[0, 1],\n)\npp.plot.rocpr(\n    X_fpns,\n    Y_fpns,\n    x_label='fpr',\n    y_label='tpr',\n    title='',\n    ax=ax[1, 0],\n)\nplt.show()\n</code></pre></p> Fig. ROC curve"},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/","title":"Pipeline 2 Drug Target Interaction Prediction","text":"<p>In this review, we supplid a deep learning method, Drutai, for sequence-based drug discovery. It uses a dataset of drug target interactions (DTIs) downloaded from DrugBank with a version: 5.1.8. The proteins are from human. Now, we show an example of whether we could use PyPropel together with other tools to quickly train a machine learning model for predicting DTIs specific to human transmembrane proteins.</p> <p>We walk you through a detailed, hands-on tutorial in achieving this purpose. First, we download the human transmembrane proteins from UniProt. Second, we download the DTIs from DrugBank. The data can be fetched from the PyPropel repository through the <code>release</code> tab, where the training and test datasets of Drutai can also be found.</p> <p>Abstract</p> <p>The key idea is to get the portion of Drutai's training and test proteins overlapped with the transmenbrane proteome. Using them, we demonstrate how to train a new predictor. Importantly, the idea can be supported step-by-step by PyPropel because the combination of a few APIs can achieve it.</p> <p>You will specifically see how PyPropel and TMKit can batch pre-process the structures of 10,971 protein complexes files (including structures of 58,060 protein chains). Finally, we will put the generated data for machine learning using scikit-learn.</p> <p>It includes 4 procedures:</p> <p>Features</p> <ul> <li> Data preparation</li> <li> Generation of training and test datasets</li> <li> Feature extraction</li> <li> Machine learning with random forest</li> </ul> <p>Let's first import both of the libraries.</p> <p> Python <pre><code>import pypropel as pp\nimport tmkit as tmk\n</code></pre></p> <p>Additionally, we will also use NumPy and Pandas for quickly processing data.</p> <p> Python <pre><code>import numpy as np\nimport pandas as pd\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/#1_data_preparation","title":"1. Data preparation","text":"<p>First, we need to split the transmembrane proteome into separate Fasta files to gain the sequences and identifiers of proteins.</p> <p> Python <pre><code>df, df_new = pp.convert.many2single(\n    fasta_fpn='data/dti/uniprotkb_KW_0812_AND_reviewed_true_AND_2024_12_08.fasta',\n    mode='uniprot',\n    species='HUMAN',\n    sv_fp='data/dti/transmembrane/',\n)\n</code></pre></p> <p>Similarly, we split the entire protein set (<code>approved.fasta</code>) into individual protein files.</p> <p>Info</p> <p>Due to different formats of the headers in Fasta files between UniProt and DrugBank, we need to specify <code>mode='uniprot'</code> or <code>mode='drugbank'</code> there to tell PyPropel to take action to tailor these formats. </p> <p> Python <pre><code>df, df_new = pp.convert.many2single(\n    fasta_fpn='data/dti/approved.fasta',\n    mode='drugbank',\n    species='',\n    sv_fp='data/dti/drugbank/',\n)\n</code></pre></p> <p>Warning</p> <p>Becasue the training set of proteins in Drutai contains the portion of proteins categorised into <code>experimental</code> by DrugBank, we will need to also extract the entire proteins from <code>expt.fasta</code>.</p> <p>We can obtain the identifiers of all UniProt's and DrugBank's transmembrane proteins this way.</p> <p> Python <pre><code>df_tm = pp.io.find_from_folder(\n    file_path='data/dti/transmembrane/',\n    suffix='.fasta',\n    flag=1,\n    sv_fpn=None,\n    # sv_fpn=to('data/find.txt'),\n)\nprint(df_tm)\n\ndf_drugbank = pp.io.find_from_folder(\n    file_path='data/dti/drugbank/',\n    suffix='.fasta',\n    flag=1,\n    sv_fpn=None,\n    # sv_fpn=to('data/find.txt'),\n)\nprint(df_drugbank)\n</code></pre></p> <p>We can gain an understanding of the quantity of drug targets that are overlapped with transmembrane proteome. </p> <p> Python <pre><code>df_drugbank_tm = df_drugbank.loc[df_drugbank[0].isin(df_tm[0].values)]\nprint(df_drugbank_tm)\n</code></pre></p> <p>Download training and test sets of Drutai from PyPropel's Github repository. They are</p> <ol> <li><code>train_pl.txt.txt</code></li> <li><code>train_nl.txt</code></li> <li><code>positive_test.txt</code></li> <li><code>negative_test.txt</code></li> </ol> <p>For example, DTIs are arranged in the <code>train_pl.txt.txt</code> file as below.</p> Fig. DTIs"},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/#2_generation_of_training_and_test_datasets","title":"2. Generation of training and test datasets","text":"<p>We can build the training set of proteins.</p> <p> Python <pre><code>df_ptrain = pp.io.read(\n    df_fpn='data/dti/train_pl.txt'\n)\ndf_ntrain = pp.io.read(\n    df_fpn='data/dti/train_nl.txt'\n)\nprint(df_ptrain)\nprint(df_ntrain)\ndf_ptrain_tm = df_ptrain.loc[df_ptrain[0].isin(df_tm[0].values)]\ndf_ntrain_tm = df_ntrain.loc[df_ntrain[0].isin(df_tm[0].values)]\ndf_ptrain_tm[2] = 1\ndf_ntrain_tm[2] = 0\nprint(df_ptrain_tm)\nprint(df_ntrain_tm)\ndf_train = (pd.concat([df_ptrain_tm, df_ntrain_tm], axis=0).reset_index(drop=True))\n</code></pre></p> <p>We can build the test set of proteins.</p> <p> Python <pre><code>df_ptest = pp.io.read(\n    df_fpn='data/dti/positive_test.txt'\n)\ndf_ntest = pp.io.read(\n    df_fpn='data/dti/negative_test.txt'\n)\n# print(df_ptest)\n# print(df_ntest)\n\ndf_ptest_tm = df_ptest.loc[df_ptest[0].isin(df_tm[0].values)]\ndf_ntest_tm = df_ntest.loc[df_ntest[0].isin(df_tm[0].values)]\ndf_ptest_tm[2] = 1\ndf_ntest_tm[2] = 0\n# print(df_ptest_tm)\n# print(df_ntest_tm)\n</code></pre></p> <p>It is important to shuffle the training dataset to ensure randomness for better machine learning.</p> <p> Python <pre><code>df_train = df_train.iloc[np.random.RandomState(1).permutation(df_train.shape[0])].reset_index(drop=True)\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/#3_feature_extraction","title":"3. Feature extraction","text":"<p>Let's now engineer a set of protein and chemical features into a <code>X</code> matrix for machine learning.</p> <p>To gain chemical features, we use the <code>RDKit</code> tool (please ensure that it has been installed in your conda environment before use). The <code>all.sdf</code> contains the structures of all molecules downloaded from DrugBank (version: 5.1.8). We store them in a dictionary <code>mols</code> for easily accessing them whenever use.</p> <p> Python <pre><code>from rdkit import Chem\nfrom rdkit.Chem import Crippen\nall_mols = Chem.SDMolSupplier('data/dti/all.sdf')\nmols = dict()\nfor mol in all_mols:\n    if mol:\n        mols[mol.GetProp('DATABASE_ID')] = mol\n</code></pre></p> <p>We set a for loop to obtain each pair of a protein and a drug molecule each time.</p> <p>Info</p> <p>The protein features include: AAC, DAC, TAC, CKSNAP, and AVEANF. The usage of all of them are shown in the documentation of PyPropel. </p> <p>We can first use protein features of AAC, DAC, and AVEANF only to gain the first sight on what the prediction performance looks like, as below.</p> <p> Python <pre><code>X = [[] for _ in range(df_train.shape[0])]\nfor i in range(df_train.shape[0]):\n    print('pair {}: {} {}'.format(i, df_train[0][i], df_train[1][i]))\n    sequence = tmk.seq.read_from_fasta(fasta_fpn='data/dti/drugbank/' + str(df_train[0][i]) + '.fasta')\n    # print(sequence)\n    # ### #/*** block AAC (20) ***/\n    aac = pp.fpseq.composition(\n        seq=sequence,\n        mode='aac',\n    )\n    aac_ = [*aac.values()]\n    aac_ = [np.float32(i) for i in aac_]    \n    for j in range(20):\n        X[i].append(aac_[j])\n\n    # ### #/*** block DAC (400) ***/\n    dac = pp.fpseq.composition(\n        seq=sequence,\n        mode='dac',\n    )\n    for j in range(400):\n        X[i].append(np.float32(dac[j][1]))\n\n    # ### #/*** block TAC (8000) ***/\n    # tac = pp.fpseq.composition(\n    #     seq=sequence,\n    #     mode='tac',\n    # )\n    # for j in range(8000):\n    #     X[i].append(np.float32(tac[j][1]))\n\n    # cksnap = pp.fpseq.composition(\n    #     seq=sequence,\n    #     mode='cksnap',\n    # )\n    # cksnap_ = [*cksnap.values()]\n    # cksnap_ = [np.float32(i) for i in cksnap_]\n    # for j in range(400):\n    #     X[i].append(cksnap_[j])\n\n    aveanf = pp.fpseq.composition(\n        seq=sequence,\n        mode='aveanf',\n    )\n    aveanf_ = [*aveanf.values()]\n    aveanf_ = [np.float32(i) for i in aveanf_]\n    for j in range(20):\n        X[i].append(aveanf_[j])\n\n    mol_name = df_train[1][i]\n\n    # LogP = Crippen.MolLogP(mols[mol_name])\n    # molar_refractivity = Crippen.MolMR(mols[mol_name])\n    # lm = np.array([LogP, molar_refractivity])\n    # # print(lm)\n    # for _, v in enumerate(lm):\n    #     X[i].append(np.float32(v))\n</code></pre></p> <p>In addition, during the feature extraction, the way we put features in can be equivalently used in putting features generated by other tools, for example, PyProtein.</p> <p> Python <pre><code> # ### #/*** block CTD (147) ***/\n# ctd_ = PyProtein.PyProtein(sequence).GetCTD()\n# ctd_values = ctd_.values()\n# for val in ctd_values:\n#     features[i].append(np.float32(val))\n</code></pre></p> <p>In the training set, we have 9426 DTIs in total. We can train the first 8000 DTIs and take the rest of them for validation of machine learning performance.</p> <p> Python <pre><code>y = df_train[2].values\n\nX_train = X[:8000]\nX_test = X[8000:]\ny_train = y[:8000]\ny_test = y[8000:]\n</code></pre></p> <p> Output <pre><code>[[ 7.3016003e-02  2.8571000e-02  2.8571000e-02 ...  5.0414350e-02\n   3.5518999e+00  1.3252400e+02]\n [ 4.2826999e-02  2.5696000e-02  5.3532999e-02 ...  4.4115603e-02\n  -1.4215300e+00  8.4962303e+01]\n [ 5.9880000e-02  5.9880000e-03  5.3892002e-02 ...  3.6085926e-02\n  -2.1226001e+00  2.7285200e+01]\n ...\n [ 1.5277800e-01  2.1825001e-02  3.7698001e-02 ...  3.0565832e-02\n  -3.4000000e-01  1.8316799e+01]\n [ 9.7156003e-02  3.3174999e-02  3.7914999e-02 ...  3.1797495e-02\n   3.3736999e+00  1.1967500e+02]\n [ 8.2608998e-02  3.2609001e-02  2.1739000e-02 ...  3.8699895e-02\n   3.8090000e+00  1.1576270e+02]]\n(9426, 442)\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/#4_machine_learning_with_random_forest","title":"4. Machine learning with random forest","text":""},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/#31_training_a_random_forest_model","title":"3.1 training a random forest model","text":"<p> Python <pre><code>from sklearn.ensemble import RandomForestClassifier\nclf = RandomForestClassifier(n_estimators=100)\nclf.fit(X_train, y_train)\n</code></pre></p>"},{"location":"tutorial/Example/Pipeline-2-Drug-Target-Interaction-Prediction/#32_evaluation","title":"3.2 evaluation","text":"<p> Python <pre><code>y_pred = clf.predict(X_test)\nprint(y_pred)\nfrom sklearn import metrics\nprint(\"Aaccuracy: \", metrics.accuracy_score(y_test, y_pred))\n</code></pre></p> <p>If we use protein features only, the aaccuracy is</p> <p> Output <pre><code>Aaccuracy: 0.7349228611500701\n</code></pre></p> <p>If we further add chemical features of LogP and molar refractivity of drug molecules, the aaccuracy becomes</p> <p> Output <pre><code>Aaccuracy: 0.7496493688639552\n</code></pre></p> <p>We can see the extra introduction of some features, prediction performance gets boosted.</p>"},{"location":"tutorial/file/IO/","title":"IO","text":""},{"location":"tutorial/file/IO/#1_get_file_names","title":"1. Get file names","text":"<p>We can get the file names in a specific directory using <code>pp.io.find_from_folder</code>.</p> <p> Python <pre><code>import pypropel as pp\n\ndf = pp.io.find_from_folder(\n    file_path=to('data/ex/xml/'),\n    suffix='.xml',\n    flag=1,\n    sv_fpn=None,\n    # sv_fpn=to('data/find.txt'),\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>29/07/2024 02:31:43 logger: ======&gt;0. Find file (like \"Q86V85\"): 1a11\n29/07/2024 02:31:43 logger: ======&gt;1. Find file (like \"Q86V85\"): 1a91\n29/07/2024 02:31:43 logger: ======&gt;2. Find file (like \"Q86V85\"): 1afo\n...\n29/07/2024 02:31:43 logger: ======&gt;8954. Find file (like \"Q86V85\"): 8wbx\n29/07/2024 02:31:43 logger: ======&gt;8955. Find file (like \"Q86V85\"): 8wd6\n         0\n0     1a11\n1     1a91\n2     1afo\n3     1aig\n4     1aij\n...    ...\n8951  8u5b\n8952  8wam\n8953  8wba\n8954  8wbx\n8955  8wd6\n\n[8956 rows x 1 columns]\n</code></pre></p> <p>Info</p> <p><code>flag</code>: which method used to suit file names. Default value: 1</p> <ul> <li> <p>1 - a general function for finding the prefixes of files</p> </li> <li> <p>2 - separate protein names and chains from file prefixes, like 1atz_A, PDBTM format</p> </li> <li> <p>3 - separate protein names and chains from file prefixes, like 1atzA</p> </li> <li> <p>4 - separate protein names and multiple chains from file prefixes, like 1atz_ABCD</p> </li> <li> <p>5 - separate protein names and multiple chains from file prefixes with regular expression</p> </li> </ul>"},{"location":"tutorial/file/IO/#2_different_and_repeated_files_between_1d_lists","title":"2. Different and repeated files between 1D lists","text":"<p>To identify different and repeated files between two lists <code>data/pdbtm_alpha_10.02.2023.txt</code> and <code>df[0]</code>, we can do</p> <p> Python <pre><code>import pypropel as pp\n\ndf_lg = pfreader().generic(to('data/pdbtm_alpha_10.02.2023.txt'), df_sep='\\t')\ndf_lg[1], df_lg[2] = zip(*df_lg[0].apply(lambda x: (x.split(\"_\")[0], x.split(\"_\")[1])))\nseries_prot_names = pd.Series(df_lg[1].unique())\n\npds_diff, psd_rept = pp.io.list_diff_unipartite(\n    pds_lg=series_prot_names,\n    pds_sm=df[0],\n    sv_diff_fpn=to('data/diff.txt'),\n    sv_rept_fpn=to('data/repeat.txt'),\n)\nprint(pds_diff)\nprint(psd_rept)\n</code></pre></p> <p> Output <pre><code># print(pds_diff)\nSeries([], dtype: object)\n\n# print(psd_rept)\n0       3zmj\n1       5mur\n2       7f92\n3       7zdv\n4       2fyn\n        ... \n8814    8a1v\n8815    7wu9\n8816    5iou\n8817    3rce\n8818    7f1s\nLength: 8819, dtype: object\n</code></pre></p> <p>In addition, we can find newly added proteins between two versions of PDBTM protein lists.</p> <p> Python <pre><code>import pypropel as pp\n\ndf_lg = pfreader().generic(to('data/pdbtm_alpha_10.02.2023.txt'), df_sep='\\t')\ndf_sm = pfreader().generic(to('data/pdbtm_alpha_06.30.2023.txt'), df_sep='\\t')\n\npds_diff, psd_rept = pp.io.list_diff_unipartite(\n    pds_lg=df_lg[0],\n    pds_sm=df_sm[0],\n    sv_diff_fpn=to('data/diff.txt'),\n    sv_rept_fpn=to('data/repeat.txt'),\n)\nprint(pds_diff)\nprint(psd_rept)\n</code></pre></p> <p> Output <pre><code>0       6s7o_A\n1       8ha2_A\n2       8j5p_P\n3       1izl_A\n4       8p3w_H\n         ...  \n2951    8t6u_A\n2952    8hju_B\n2953    6zjy_H\n2954    4qkm_B\n2955    6hjr_D\nLength: 2956, dtype: object\n0        5va3_A\n1        8f4f_T\n2        6yto_F\n3        4knf_D\n4        2xq3_A\n          ...  \n33371    6nt7_B\n33372    6jlo_Z\n33373    8h9j_8\n33374    6idf_E\n33375    5jtg_E\nLength: 33376, dtype: object\n</code></pre></p>"},{"location":"tutorial/file/IO/#3_different_and_repeated_files_between_2d_lists","title":"3. Different and repeated files between 2D lists","text":"<p>We can get the list of Different and repeated files between 2D lists. It drops duplicates by considering two columns in lists.</p> <p> Python <pre><code>import pypropel as pp\n\ndf = pd.DataFrame()\ndf1 = pd.DataFrame()\n\ndf[0], df[1] = zip(*pds_diff.apply(lambda x: (x.split(\"_\")[0], x.split(\"_\")[1])))\ndf1[0], df1[1] = zip(*df_lg[0].apply(lambda x: (x.split(\"_\")[0], x.split(\"_\")[1])))\nprint(df)\nprint(df1)\n\ndf_differ, df_repeat = pp.io.list_diff_bipartite(\n    pds_lg_1=df[0],\n    pds_lg_2=df[1],\n    pds_sm_1=df1[0],\n    pds_sm_2=df1[1],\n    sv_diff_fpn=to('data/diff1.txt'),\n    sv_rept_fpn=to('data/repeat1.txt'),\n)\nprint(df_differ)\nprint(df_repeat)\n</code></pre></p> <p> Output <pre><code># df_differ\nEmpty DataFrame\nColumns: []\nIndex: []\n\n# df_repeat\n         0  1\n0     8t2v  A\n1     6b8h  3\n2     8p3s  H\n3     7thu  K\n4     8bx5  C\n...    ... ..\n2951  7a24  V\n2952  6vam  B\n2953  8go3  C\n2954  8c29  n\n2955  6psn  F\n\n[2956 rows x 2 columns]\n</code></pre></p>"},{"location":"tutorial/file/IO/#4_move_copy_remove_rename_create","title":"4. move, copy, remove, rename, create","text":"<p>PyPropel also provides a few <code>move</code>, <code>copy</code>, <code>remove</code>, <code>rename</code>, <code>create</code> operations on a list of IDs rendered in pandas Series format.</p> <pre><code>move_files\ncopy_files\ndelete_files\nrename_file_suffix\nrename_file_prefix\nmakedir\n</code></pre> <p>Below shows an example that a list of proteins are moved from <code>data/isoform/</code> to <code>data/isoform/transmembrane/</code>.</p> <p> Python <pre><code>df_cano = pp.io.find_from_folder(\n    file_path='data/canonical/',\n    suffix='.fasta',\n    flag=1,\n    sv_fpn=None,\n    # sv_fpn=to('data/find.txt'),\n)\nprint(df_cano)\n\ndf_isof = pp.io.find_from_folder(\n    file_path='data/isoform/',\n    suffix='.fasta',\n    flag=1,\n    sv_fpn=None,\n    # sv_fpn=to('data/find.txt'),\n)\nprint(df_isof)\n\ndf_isof['canonical'] = df_isof[0].apply(lambda x: x.split('-')[0])\nprint(df_isof)\n\ndf_isof_tm = df_isof.loc[df_isof['canonical'].isin(df_cano[0].values)]\nprint(df_isof_tm)\n\npp.io.move_files(\n    pds_mv=df_isof_tm[0],\n    mv_from_fp='data/isoform/',\n    mv_to_fp='data/isoform/transmembrane/',\n    suffix='.fasta',\n)\n</code></pre></p>"},{"location":"tutorial/protein/convert/","title":"Convert","text":""},{"location":"tutorial/protein/convert/#1_combining_single_proteins_into_one","title":"1. Combining single proteins into one","text":"<p>1.1 Command</p> <pre><code>import pypropel as pp\n\ndf = pp.convert.single2many(\n    fasta_fp=to('data/fasta/'),\n    prot_df=pd.DataFrame({\n        'prot': ['1aig', '1aij', '1xqf'],\n        'chain': ['L', 'L', 'A'],\n    }),\n    sv_fpn=to('data/fasta/s2m.fasta')\n)\n</code></pre> <p>1.2 Results</p> OutputConsole <pre><code>&gt;1aigL\nALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n&gt;1aijL\nALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n&gt;1xqfA\nAVADKADNAFMMICTALVLFMTIPGIALFYGGLIRGKNVLSMLTQVTVTFALVCILWVVYGYSLAFGEGNNFFGNINWLMLKNIELTAVMGSIYQYIHVAFQGSFACITVGLIVGALAERIRFSAVLIFVVVWLTLSYIPIAHMVWGGGLLASHGALDFAGGTVVHINAAIAGLVGAYLPHNLPMVFTGTAILYIGWFGFNAGSAGTANEIAALAFVNTVVATAAAILGWIFGEWALRGKPSLLGACSGAIAGLVGVTPACGYIGVGGALIIGVVAGLAGLWGVTMPCDVFGVHGVCGIVGCIMTGIFAASSLGGVGFAEGVTMGHQLLVQLESIAITIVWSGVVAFIGYKLADLTVGLRVP\n</code></pre> <pre><code>27/07/2024 01:36:24 logger: =========&gt;integrate 3 protein sequences\n27/07/2024 01:36:24 logger: =========&gt;save fasta to files\n27/07/2024 01:36:24 logger: =========&gt;save finished\n</code></pre>"},{"location":"tutorial/protein/convert/#2_splitting_into_single_proteins","title":"2. Splitting into single proteins","text":"<p>1.1 Proteins from DrugBank</p> <pre><code>import pypropel as pp\n\ndf, df_new = pp.convert.many2single(\n    fasta_fpn=to('data/msa/experimental_protein.fasta'),\n    sv_fp=to('data/msa/')\n)\n</code></pre> <p>1.2 Fasta from UniProt Only extract human proteins by adding species as 'HUMAN'.</p> <pre><code>import pypropel as pp\n\ndf, df_new = pp.convert.many2single(\n    fasta_fpn=to('data/uniprotkb_KW_0812_AND_reviewed_true_AND_2024_12_08.fasta'),\n    mode='uniprot',\n    species='HUMAN',\n    sv_fp=to('data/')\n)\n</code></pre> OutputConsole <pre><code>There are 2888 fasta files in output directory to('data/msa/').\n</code></pre> <pre><code>    27/07/2024 02:17:26 logger: =========&gt;content of the dataframe:\n Index(['fasta_ids', 'fasta_seqs', 'fasta_names', 'fasta_dpts', 'target_ids',\n       'drug_ids'],\n      dtype='object')\n27/07/2024 02:17:26 logger: =========&gt;target IDs:\n 0       P45059\n1       P19113\n2       Q9UI32\n3       P00488\n4       P35228\n         ...  \n3272    P07766\n3273    P09693\n3274    P20963\n3275    P03420\n3276    P11209\nName: target_ids, Length: 3277, dtype: object\n27/07/2024 02:17:26 logger: =========&gt;start to split into single fasta files\n27/07/2024 02:17:26 logger: =========&gt;# of proteins: 3277\n27/07/2024 02:17:26 logger: =========&gt;# of proteins after deduplication: 2888\n</code></pre> Fig 1. Converted Fasta files"},{"location":"tutorial/protein/convert/#3_extract_sequences_from_msa","title":"3. Extract sequences from MSA","text":"<p><code>pp.convert.msa2fas</code> can extract each homolog from a MSA to write in Fasta format.</p> <p> Python <pre><code>import pypropel as pp\n\npp.convert.msa2fas(\n    input_fpn=to('data/msa/a2m/ET.a2m'),\n    output_fp=to('data/msa/a2m/'),\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 09:37:52 logger: =========&gt;extract E to save\n28/07/2024 09:37:52 logger: =========&gt;extract UR100_A0A023PSW1 to save\n28/07/2024 09:37:52 logger: =========&gt;extract UR100_A0A088DKU1 to save\n28/07/2024 09:37:52 logger: =========&gt;extract UR100_A0A0K1Z002 to save\n...\n28/07/2024 09:37:52 logger: =========&gt;extract UR100_U3M734 to save\n28/07/2024 09:37:52 logger: =========&gt;extract UR100_V5N926 to save\n'Finished'\n</code></pre></p>"},{"location":"tutorial/protein/convert/#4_convert_bewteen_msa_formats","title":"4. Convert bewteen MSA formats","text":"<p><code>pp.convert.msa_reformat</code> can convert a MSA from one to another format, e.g., from fasta format to stockholm format.</p> <p> Python <pre><code>import pypropel as pp\n\npp.convert.msa_reformat(\n    input_fpn=to('data/msa/a2m/ET.a2m'),\n    in_format='fasta',\n    output_fpn=to('data/msa/a2m/ET_converted.sto'),\n    out_format='stockholm',\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 09:53:30 logger: =========&gt; convert from fasta to stockholm\n'Finished'\n</code></pre></p>"},{"location":"tutorial/protein/convert/#5_convert_from_pdb_to_fasta","title":"5. Convert from PDB to FASTA","text":"<p>To perform this conversion, a <code>pp.str</code> module is used.</p> <p> Python <pre><code>import pypropel as pp\n\nprot_df = pd.DataFrame({\n    'prot': ['1aig', '1aij', '1xqf'],\n    'chain': ['L', 'L', 'A'],\n})\n\npp.str.tofasta(\n    prot_df,\n    sv_fp=to('data/'),\n    pdb_path=to('data/pdb/pdbtm/'),\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 17:00:02 logger: ============&gt;No0. protein 1aig chain L\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\PDBParser.py:395: PDBConstructionWarning: Ignoring unrecognized record 'END' at line 2234\n  warnings.warn(\n28/07/2024 17:00:02 logger: ===============&gt;successfully converted\n28/07/2024 17:00:02 logger: ============&gt;No1. protein 1aij chain L\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\PDBParser.py:395: PDBConstructionWarning: Ignoring unrecognized record 'END' at line 2234\n  warnings.warn(\n28/07/2024 17:00:02 logger: ===============&gt;successfully converted\n28/07/2024 17:00:02 logger: ============&gt;No2. protein 1xqf chain A\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\PDBParser.py:395: PDBConstructionWarning: Ignoring unrecognized record 'END' at line 2634\n  warnings.warn(\n28/07/2024 17:00:03 logger: ===============&gt;successfully converted\nfinished\n</code></pre></p>"},{"location":"tutorial/protein/IO/dataset/","title":"Dataset","text":"<p>We can generate a dataset of protein structures, XML, and sequences simutaneously using <code>pp.dataset.download_pack</code>.</p> <p>Warning</p> <p><code>pdb_cplx_fp</code> must be use to direct <code>pp.dataset.download_pack</code> to a directory where protein complex structures are stored.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dataset.download_pack(\n    prot_df=prot_df,\n    pdb_cplx_fp=to('data/pdb/complex/pdbtm/'),\n    pdb_fp=to('data/tmp/'),\n    xml_fp=to('data/tmp/'),\n    fasta_fp=to('data/tmp/'),\n)\n</code></pre></p> <p> Output <pre><code>29/07/2024 00:54:14 logger: =========&gt;++++++++++++++++++++split into chains...\n+++++++++++++++++++++++++++\n29/07/2024 00:54:14 logger: ============&gt;No0. protein 1aig chain L\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Atom.py:232: PDBConstructionWarning: Could not assign element 'M' for Atom (name=MG) with given element 'M'\n  warnings.warn(msg, PDBConstructionWarning)\n29/07/2024 00:54:14 logger: ================&gt;success in building 1aigL model.\n29/07/2024 00:54:14 logger: ============&gt;No1. protein 1aij chain L\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Atom.py:232: PDBConstructionWarning: Could not assign element 'M' for Atom (name=MG) with given element 'M'\n  warnings.warn(msg, PDBConstructionWarning)\n29/07/2024 00:54:14 logger: ================&gt;success in building 1aijL model.\n29/07/2024 00:54:14 logger: ============&gt;No2. protein 1xqf chain A\n29/07/2024 00:54:14 logger: ================&gt;success in building 1xqfA model.\n29/07/2024 00:54:14 logger: =========&gt;++++++++++++++++++++delete END from PDB files...\n+++++++++++++++++++++++++++\n29/07/2024 00:54:14 logger: ============&gt;No0. protein 1aig chain L\n29/07/2024 00:54:14 logger: ===============&gt;Successfully reformatted\n29/07/2024 00:54:14 logger: ============&gt;No1. protein 1aij chain L\n29/07/2024 00:54:14 logger: ===============&gt;Successfully reformatted\n29/07/2024 00:54:14 logger: ============&gt;No2. protein 1xqf chain A\n29/07/2024 00:54:14 logger: ===============&gt;Successfully reformatted\n29/07/2024 00:54:14 logger: =========&gt;++++++++++++++++++++remove hetatm from PDB files...\n+++++++++++++++++++++++++++\n29/07/2024 00:54:14 logger: ============&gt;No.1 protein 1aig chain L\n29/07/2024 00:54:14 logger: ============&gt;No.2 protein 1aij chain L\n29/07/2024 00:54:14 logger: ============&gt;No.3 protein 1xqf chain A\n29/07/2024 00:54:14 logger: =========&gt;++++++++++++++++++++is match...\n+++++++++++++++++++++++++++\n29/07/2024 00:54:14 logger: ============&gt;No0. protein 1aig chain L\n29/07/2024 00:54:14 logger: ============&gt;File does not exist\n29/07/2024 00:54:14 logger: ============&gt;No1. protein 1aij chain L\n29/07/2024 00:54:14 logger: ============&gt;File does not exist\n29/07/2024 00:54:14 logger: ============&gt;No2. protein 1xqf chain A\n29/07/2024 00:54:14 logger: ============&gt;File does not exist\n29/07/2024 00:54:14 logger: =========&gt;++++++++++++++++++++to Fasta...\n+++++++++++++++++++++++++++\n29/07/2024 00:54:14 logger: ============&gt;No0. protein 1aig chain L\n29/07/2024 00:54:14 logger: ===============&gt;successfully converted\n29/07/2024 00:54:14 logger: ============&gt;No1. protein 1aij chain L\n29/07/2024 00:54:14 logger: ===============&gt;successfully converted\n29/07/2024 00:54:14 logger: ============&gt;No2. protein 1xqf chain A\n29/07/2024 00:54:14 logger: ===============&gt;successfully converted\n29/07/2024 00:54:14 logger: =========&gt;++++++++++++++++++++is empty...\n+++++++++++++++++++++++++++\n29/07/2024 00:54:14 logger: ============&gt;No0. protein 1aig chain L\n29/07/2024 00:54:14 logger: ============&gt;No1. protein 1aij chain L\n29/07/2024 00:54:14 logger: ============&gt;No2. protein 1xqf chain A\nFinished\n</code></pre></p> <p>Then, we can see all downloaded structure, XML, and sequence files there.</p> Fig 1. Downloaded dataset"},{"location":"tutorial/protein/IO/msa/","title":"Msa","text":""},{"location":"tutorial/protein/IO/msa/#read","title":"Read","text":"<p>Users can operate multiple sequence alignments (MSAs) with the <code>pp.msa.read</code> module.</p> <p> Python <pre><code>import pypropel as pp\n\nmsa = pp.msa.read(\n    msa_fpn=to('data/msa/aln/1aijL.aln'),\n)\nprint(msa[:3])\n</code></pre></p> <p>It returns a 1D list. Each element represents a homolog of the query protein sequence (the 1st protein). The first 3 sequences in the MSA of protein <code>1aijL</code> is given below.</p> <p> Output <pre><code>['ALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING', '-------------------------------------AVFCALMGTALIIWNTPLGPTWNLWQISVNPPDVKYGLGFAPLAEGGIWQWVTIFAIGAFCSWALREVEICRKLGIGYHVPFAFSFAIFAYVTLVVIRPVLMGSWSYGFPYGIFTHLDWVSNTGYQYGQFHWNPGHMIAITFFFTTCLALALHGGLVLSAINPDRGEPVKSPEHENTVFRDLVGYSIGTIGIHRVGLFLALSAVFWSAVCMLISGPVLGGSWPEWWEWWRRIPIWNP-------', '--------------------------------------IFFASLGICFIGYAASQGPTWDPFAISINPPDLKYGFAAAPLLEGGFWQAITVCALGAFFSWMLREVEISRKLGMGWHVPLAFCVPIFMFCVLQVFRPILMGGWGFAFPYGILSHLDWVNNFGFQYLNWHYNPGHMSSVSFLFCNAMALGLHGGLILSVTNPGDGDKVKTAEHENAYFRDVVGYSIGALAIHRLGLFLASNIFLTGAFGTIASGPFWTRGWPEWWGWWLDIPFWS--------',\n...\n]\n</code></pre></p>"},{"location":"tutorial/protein/IO/msa/#frequency","title":"Frequency","text":"<p>We next calculate the frequencies of amino acids at each column.</p> <p> Python <pre><code>import pypropel as pp\n\nfreq_col = pp.msa.freq_col_sgl(msa=msa)\nprint(freq_col)\n</code></pre></p> <p> Output <pre><code>{'A': array([4.80810828e-02, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 3.09004388e-04, 0.00000000e+00,\n       0.00000000e+00, 6.18008776e-05, ..., 1.85402633e-04, 6.79809653e-04,\n       6.18008776e-05]), 'C': array([0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, ...\n       }\n</code></pre></p> <p>The frequency of amino acids across the whole MSA.</p> <p> Python <pre><code>import pypropel as pp\n\nfreq_whole = pp.msa.freq_whole_sgl(msa=msa)\nprint(freq_whole)\n</code></pre></p> <p> Output <pre><code>{'A': 0.05826085292688736, 'C': 0.004700385606685579, 'D': 0.008600878716107662, 'E': 0.015672130729309737, 'F': 0.05294113895278523, 'G': 0.06534156201388167, 'H': 0.019759785927038455, 'I': 0.04494023459261235, 'K': 0.0027040633087310126, 'L': 0.05968535215833517, 'M': 0.022540825417799226, 'N': 0.01639108826946766, 'P': 0.03155605592517563, 'Q': 0.011760641022454832, 'R': 0.017077715813173088, 'S': 0.03935616241622517, 'T': 0.02184298134471232, 'V': 0.040838283818220966, 'W': 0.01871466930702302, 'Y': 0.0222107075628659, '-': 0.42443809036607894}\n</code></pre></p> <p>Then, we can caluclate the frequency of amino acid pairs for any two columns in the MSA.</p> <p> Python <pre><code>import pypropel as pp\n\nfreq_whole = pp.msa.freq_whole_sgl(msa=msa)\nprint(freq_whole)\n</code></pre></p> <p> Output <pre><code>{'AA': 0.0, 'AC': 0.0, 'AD': 0.0, ..., '-W': 0.0, '-Y': 0.0, '--': 0.9465422408998208}\n</code></pre></p>"},{"location":"tutorial/protein/IO/msa/#count","title":"Count","text":"<p>The count of amino acids at each column.</p> <p> Python <pre><code>import pypropel as pp\n\ncnt_col = pp.msa.cnt_col_sgl(msa=msa)\nprint(cnt_col)\n</code></pre></p> <p> Output <pre><code>{'A': [778, 0, 0, 0, 0, 0, 5, ...], 'C': [0, 0, 0, 0, 0, 0, 0, ...], ...}\n</code></pre></p>"},{"location":"tutorial/protein/IO/msa/#representation","title":"Representation","text":""},{"location":"tutorial/protein/IO/msa/#onehot","title":"Onehot","text":"<p>We use one-hot encodings to represent a MSA matrix.</p> <p> Python <pre><code>import pypropel as pp\n\noh_rep = pp.msa.representation_onehot(\n    msa=msa # 1aijL\n)\nprint(oh_rep)\nprint(oh_rep.shape)\n</code></pre></p> <p>The length of the column is 281*21=5901, where 21 means 21 symbols including gap <code>-</code>.</p> <p> Output <pre><code>[[1 0 0 ... 0 0 0]\n [0 0 0 ... 0 0 1]\n [0 0 0 ... 0 0 1]\n ...\n [0 0 0 ... 0 0 1]\n [0 0 0 ... 0 0 1]\n [0 0 0 ... 0 0 1]]\n(16181, 5901)\n</code></pre></p>"},{"location":"tutorial/protein/IO/msa/#frequency_1","title":"Frequency","text":"<p>We use frequencies of amino acids to represent a MSA matrix.</p> <p> Python <pre><code>import pypropel as pp\n\noh_rep = pp.msa.representation_freq(\n    msa=msa # 1aijL\n)\nprint(oh_rep)\nprint(oh_rep.shape)\n</code></pre></p> <p> Output <pre><code>[[0.0481 0.0256 0.0526 ... 0.0024 0.0067 0.0085]\n [0.     0.     0.     ... 0.     0.     0.    ]\n [0.     0.     0.     ... 0.     0.     0.    ]\n ...\n [0.     0.     0.     ... 0.     0.     0.    ]\n [0.     0.     0.     ... 0.     0.     0.    ]\n [0.     0.     0.     ... 0.     0.     0.    ]]\n</code></pre></p>"},{"location":"tutorial/protein/IO/msa/#split","title":"Split","text":"<p>We can split a string of a sequence into capital letters of a list.</p> <p> Python <pre><code>import pypropel as pp\n\nl = pp.msa.split(\n    msa=msa # 1aijL\n)\nprint(l)\n</code></pre></p> <p> Output <pre><code>[['A', 'L', 'L', 'S', 'F', 'E', 'R', 'K', 'Y', 'R', 'V', 'P', 'G', 'G', 'T', 'L', 'V', 'G', 'G', 'N', 'L', 'F', 'D', 'F', 'W', 'V', 'G', 'P', 'F', 'Y', 'V', 'G', 'F', 'F', 'G', 'V', 'A', 'T', 'F', 'F', 'F', 'A', 'A', 'L', 'G', 'I', 'I', 'L', 'I', 'A', 'W', 'S', 'A', 'V', 'L', 'Q', 'G', 'T', 'W', 'N', 'P', 'Q', 'L', 'I', 'S', 'V', 'Y', 'P', 'P', 'A', 'L', 'E', 'Y', 'G', 'L', 'G', 'G', 'A', 'P', 'L', 'A', 'K', 'G', 'G', 'L', 'W', 'Q', 'I', 'I', 'T', 'I', 'C', 'A', 'T', 'G', 'A', 'F', 'V', 'S', 'W', 'A', 'L', 'R', 'E', 'V', 'E', 'I', 'C', 'R', 'K', 'L', 'G', 'I', 'G', 'Y', 'H', 'I', 'P', 'F', 'A', 'F', 'A', 'F', 'A', 'I', 'L', 'A', 'Y', 'L', 'T', 'L', 'V', 'L', 'F', 'R', 'P', 'V', 'M', 'M', 'G', 'A', 'W', 'G', 'Y', 'A', 'F', 'P', 'Y', 'G', 'I', 'W', 'T', 'H', 'L', 'D', 'W', 'V', 'S', 'N', 'T', 'G', 'Y', 'T', 'Y', 'G', 'N', 'F', 'H', 'Y', 'N', 'P', 'A', 'H', 'M', 'I', 'A', 'I', 'S', 'F', 'F', 'F', 'T', 'N', 'A', 'L', 'A', 'L', 'A', 'L', 'H', 'G', 'A', 'L', 'V', 'L', 'S', 'A', 'A', 'N', 'P', 'E', 'K', 'G', 'K', 'E', 'M', 'R', 'T', 'P', 'D', 'H', 'E', 'D', 'T', 'F', 'F', 'R', 'D', 'L', 'V', 'G', 'Y', 'S', 'I', 'G', 'T', 'L', 'G', 'I', 'H', 'R', 'L', 'G', 'L', 'L', 'L', 'S', 'L', 'S', 'A', 'V', 'F', 'F', 'S', 'A', 'L', 'C', 'M', 'I', 'I', 'T', 'G', 'T', 'I', 'W', 'F', 'D', 'Q', 'W', 'V', 'D', 'W', 'W', 'Q', 'W', 'W', 'V', 'K', 'L', 'P', 'W', 'W', 'A', 'N', 'I', 'P', 'G', 'G', 'I', 'N', 'G'], ...]\n</code></pre></p>"},{"location":"tutorial/protein/IO/sequence/","title":"Sequence","text":""},{"location":"tutorial/protein/IO/sequence/#read","title":"Read","text":"<p>PyPropel reads a protein sequence in FASTA format with the <code>pp.seq.read</code> module.</p> <p> Python <pre><code>import pypropel as pp\n\nseq = pp.seq.read(\n    fasta_fpn=to('data/fasta/1aigL.fasta'),\n)\nprint(seq)\n</code></pre></p> <p> Output <pre><code>ALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n</code></pre></p>"},{"location":"tutorial/protein/IO/sequence/#save","title":"Save","text":"<p>A protein sequence can be saved.</p> <p> Python <pre><code>import pypropel as pp\n\nseq = pp.seq.save(\n    list_2d=[\n        ['1aigL-new', seq],\n    ],\n    sv_fp=to('data/fasta/'),\n)\n</code></pre></p> <p> Output <pre><code>No.1 saving 1aigL-new in FASTA format.\n</code></pre></p>"},{"location":"tutorial/protein/IO/sequence/#check_empty","title":"Check empty","text":"<p>You can check if all sequences are empty.</p> <p> Python <pre><code>import pypropel as pp\n\nprot_df = pd.DataFrame({\n    'prot': ['1aig', '1aij', '1xqf'],\n    'chain': ['L', 'L', 'A'],\n})\n\nseq = pp.seq.is_empty(\n    prot_df=prot_df,\n    fasta_fp=to('data/fasta/'),\n    sv_empty_fp=to('data/'),\n)\n</code></pre></p> <p> Output <pre><code>27/07/2024 22:14:29 logger: ============&gt;No0. protein 1aig chain L\n27/07/2024 22:14:29 logger: ============&gt;No1. protein 1aij chain L\n27/07/2024 22:14:29 logger: ============&gt;No2. protein 1xqf chain A\nFinished\n</code></pre></p>"},{"location":"tutorial/protein/IO/sequence/#check_match","title":"Check match","text":"<p>You can check if all sequences in one format match those in another format. Below shows if sequences in FASTA format match those in XML format.</p> <p> Python <pre><code>import pypropel as pp\n\nprot_df = pd.DataFrame({\n    'prot': ['1aig', '1aij', '1xqf'],\n    'chain': ['L', 'L', 'A'],\n})\n\nseq = pp.seq.is_match(\n    prot_df=prot_df,\n    fasta_path=to('data/fasta/'),\n    # pdb_path=to('data/pdb/pdbtm/'),\n    xml_path=to('data/xml/'),\n    kind='fasta&lt;-&gt;xml',\n    sv_mismatch_fp=to('data/'),\n)\n</code></pre></p> <p> Output <pre><code>27/07/2024 22:17:32 logger: ============&gt;No0. protein 1aig chain L\n27/07/2024 22:17:32 logger: ============&gt;They match.\n27/07/2024 22:17:32 logger: ============&gt;No1. protein 1aij chain L\n27/07/2024 22:17:32 logger: ============&gt;They match.\n27/07/2024 22:17:32 logger: ============&gt;No2. protein 1xqf chain A\n27/07/2024 22:17:32 logger: ============&gt;They do not match.\nFinished\n</code></pre></p>"},{"location":"tutorial/protein/IO/structure/","title":"Structure","text":""},{"location":"tutorial/protein/IO/structure/#1_read","title":"1. Read","text":"<p>PyPropel pre-processes a protein structure in PDB format with a variety of functions to generate a new structure tailored for the analysis need.</p> <p> Python <pre><code>import pypropel as pp\n\nseq = pp.str.read(\n    pdb_path=to('data/pdb/pdbtm/'),\n    pdb_name='1aij',\n    file_chain='L',\n    seq_chain='L',\n)\nprint(seq)\n</code></pre></p> <p> Output <pre><code>ALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n</code></pre></p>"},{"location":"tutorial/protein/IO/structure/#2_splitting_a_complex_into_chains","title":"2. Splitting a complex into chains","text":"<p>If there is a list of protein chains, the following code allows you to extract single chains from a protein complex.</p> <p> Python <pre><code>import pypropel as pp\n\nprot_df = pd.DataFrame({\n    'prot': ['1aig', '1aij', '1xqf'],\n    'chain': ['L', 'L', 'A'],\n})\n\npp.str.split_cplx_to_sgl(\n    prot_df=prot_df,\n    pdb_path=to('data/pdb/complex/pdbtm/'),\n    sv_fp=to('data/'),\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 17:28:16 logger: ============&gt;No0. protein 1aig chain L\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Atom.py:232: PDBConstructionWarning: Could not assign element 'M' for Atom (name=MG) with given element 'M'\n  warnings.warn(msg, PDBConstructionWarning)\n28/07/2024 17:28:16 logger: ================&gt;success in building 1aigL model.\n28/07/2024 17:28:16 logger: ============&gt;No1. protein 1aij chain L\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Atom.py:232: PDBConstructionWarning: Could not assign element 'M' for Atom (name=MG) with given element 'M'\n  warnings.warn(msg, PDBConstructionWarning)\n28/07/2024 17:28:16 logger: ================&gt;success in building 1aijL model.\n28/07/2024 17:28:16 logger: ============&gt;No2. protein 1xqf chain A\n28/07/2024 17:28:16 logger: ================&gt;success in building 1xqfA model.\nFinished\n</code></pre></p>"},{"location":"tutorial/protein/IO/structure/#3_delete_end_from_pdb","title":"3. Delete END from PDB","text":"<p>In reality, we might extract the 3D coordinates of a single protein chain from a PDB structure. Due to unproper formatting, the extracted structure may contain something irrelevant, posing a challenge for downstream analysis. For example, to get the correct information about the relative solvent accessibility (RSA), DSSP needs a PDB file without <code>END</code> in the end of the PDB file. We can use the following code to remove the mark in bulk.</p> <p> Python <pre><code>import pypropel as pp\n\nprot_df = pd.DataFrame({\n    'prot': ['1aig', '1aij', '1xqf'],\n    'chain': ['L', 'L', 'A'],\n})\n\npp.str.del_end(\n    prot_df,\n    sv_fp=to('data/'),\n    pdb_path=to('data/pdb/pdbtm/'),\n)\n</code></pre></p> <p>Before deletion, the PDB file has a <code>END</code> in the end. <pre><code>ATOM      1  N   ALA L   1     -27.710  -2.809 -20.227  1.00 61.86           N  \nATOM      2  CA  ALA L   1     -26.559  -3.484 -19.659  1.00 62.35           C  \nATOM      3  C   ALA L   1     -25.256  -3.284 -20.413  1.00 62.67           C  \n......\nATOM   2232  OXT GLY L 281      28.878   2.108  26.859  1.00 74.20           O  \nTER    2233      GLY L 281                                                       \nEND\n</code></pre></p> <p> Output <pre><code>28/07/2024 17:03:30 logger: ============&gt;No0. protein 1aig chain L\n28/07/2024 17:03:30 logger: ===============&gt;Successfully reformatted\n28/07/2024 17:03:30 logger: ============&gt;No1. protein 1aij chain L\n28/07/2024 17:03:30 logger: ===============&gt;Successfully reformatted\n28/07/2024 17:03:30 logger: ============&gt;No2. protein 1xqf chain A\n28/07/2024 17:03:30 logger: ===============&gt;Successfully reformatted\nFinished\n</code></pre></p> <p>After <code>pp.str.del_end</code> is used, the PDB file looks like. <pre><code>ATOM      1  N   ALA L   1     -27.710  -2.809 -20.227  1.00 61.86           N  \nATOM      2  CA  ALA L   1     -26.559  -3.484 -19.659  1.00 62.35           C  \nATOM      3  C   ALA L   1     -25.256  -3.284 -20.413  1.00 62.67           C  \n......\nATOM   2232  OXT GLY L 281      28.878   2.108  26.859  1.00 74.20           O  \nTER    2233      GLY L 281                                                 \n</code></pre></p>"},{"location":"tutorial/protein/IO/structure/#4_remove_hetatm","title":"4. Remove HETATM","text":"<p>In molecular structures of PDB (Protein Data Bank) files, HETATM (Hetero Atom) refers to atoms that are not part of standard amino acid or nucleic acid residues. These heteroatoms typically include:</p> <ol> <li>Ligands: Small molecules or ions that bind to proteins or nucleic acids.</li> <li>Cofactors: Non-protein chemical compounds or metallic ions required for protein activity.</li> <li>Water Molecules: Included in crystal structures.</li> </ol> <p>To remove this part, users can do</p> <p> Python <pre><code>import pypropel as pp\n\nprot_df = pd.DataFrame({\n    'prot': ['1aig', '1aij', '1xqf'],\n    'chain': ['L', 'L', 'A'],\n})\n\npp.str.remove_hetatm(\n    prot_df=prot_df,\n    pdb_path=to('data/pdb/complex/pdbtm/'),\n    sv_fp=to('data/pdb/'),\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 17:44:07 logger: ============&gt;No.1 protein 1aig chain L\n28/07/2024 17:44:07 logger: ============&gt;No.2 protein 1aij chain L\n28/07/2024 17:44:07 logger: ============&gt;No.3 protein 1xqf chain A\n</code></pre></p>"},{"location":"tutorial/protein/distance/chain/","title":"Chain","text":""},{"location":"tutorial/protein/distance/chain/#1_distance_calculation","title":"1. Distance calculation","text":"<p>We calculate the distance between residues from two given chains. The <code>pp.dist.one_vs_one</code> makes a one-against-one comparison between residues.</p> <p> Python <pre><code>import pypropel as pp\n\ndist_mat = pp.dist.one_vs_one(\n    pdb_path1=to('data/pdb/complex/pdbtm/'),\n    pdb_name1='1aij',\n    file_chain1='',\n    seq_chain1='L',\n    pdb_path2=to('data/pdb/complex/pdbtm/'),\n    pdb_name2='1aij',\n    file_chain2='',\n    seq_chain2='M',\n)\ndf_dist = pd.DataFrame(dist_mat)\ndf_dist = df_dist.rename(columns={\n    0: 'res_fas_id1',\n    1: 'res1',\n    2: 'res_pdb_id1',\n    3: 'res_fas_id2',\n    4: 'res2',\n    5: 'res_pdb_id2',\n    6: 'dist',\n})\nprint(df_dist)\n</code></pre></p> <p> Output <pre><code>       res_fas_id1 res1  res_pdb_id1  res_fas_id2 res2  res_pdb_id2       dist\n0                1    A            1            1    A            1  33.363850\n1                1    A            1            2    E            2  27.019474\n2                1    A            1            3    Y            3  29.652020\n3                1    A            1            4    Q            4  28.374273\n4                1    A            1            5    N            5  29.460558\n...            ...  ...          ...          ...  ...          ...        ...\n84576          281    G          281       -27423    W          297  41.042576\n84577          281    G          281       -27422    G          298  42.089241\n84578          281    G          281       -27421    Q          299  43.358837\n84579          281    G          281       -27420    N          300  44.846886\n84580          281    G          281       -27419    H          301  46.933315\n\n[84581 rows x 7 columns]\n</code></pre></p>"},{"location":"tutorial/protein/distance/chain/#2_check_interaction","title":"2. Check interaction","text":"<p>Each residue in the chain 1 has a minimum distance against all of residues in the chain 2. It stops the calculations of the minimum distance of each residue to each residue in the chain 2 when it detects a minimum distance of less than <code>thres</code>, 6 by default. <code>pp.dist.check_chain_complex</code> checks two chains given.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dist.check_chain_paired(\n    pdb_fp1=to('data/pdb/pdbtm/'),\n    pdb_fp2=to('data/pdb/pdbtm/'),\n    prot_name1='1aij',\n    prot_name2='1aij',\n    prot_chain1='L',\n    prot_chain2='M',\n    thres=6.,\n    sv_fp=to('data/pdb/pdbtm/'),\n)\n</code></pre></p> <p> Output <pre><code>D:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\PDBParser.py:395: PDBConstructionWarning: Ignoring unrecognized record 'END' at line 2234\n  warnings.warn(\n28/07/2024 20:02:04 logger: =========&gt;Protein PDB code 1: 1aij\n28/07/2024 20:02:04 logger: =========&gt;Protein PDB chain 1: L\n28/07/2024 20:02:04 logger: =========&gt;Protein PDB code 2: 1aij\n28/07/2024 20:02:04 logger: =========&gt;Protein PDB chain 2: M\n28/07/2024 20:02:04 logger: ==================&gt;residue 1 ID: 0\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\PDBParser.py:395: PDBConstructionWarning: Ignoring unrecognized record 'END' at line 2406\n  warnings.warn(\n28/07/2024 20:02:04 logger: ==================&gt;residue 0 and residue 252 in interaction\n</code></pre></p> <p>The results are saved to the <code>1aijL_1aijM.pcheck</code> file. It has the following content. <pre><code>1aij    L\n1aij    M\n</code></pre></p>"},{"location":"tutorial/protein/distance/complex/","title":"Complex","text":""},{"location":"tutorial/protein/distance/complex/#1_distance_calculation","title":"1. Distance calculation","text":"<p>We calculate the distance between residues from every two chains within a protein complex. The <code>pp.dist.all_vs_all</code> makes a all-against-all comparison between residues.</p> <p> Python <pre><code>import pypropel as pp\n\ndf = pp.dist.all_vs_all(\n    pdb_fp=to('data/pdb/complex/pdbtm/'),\n    pdb_name='1aij',\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>D:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Atom.py:232: PDBConstructionWarning: Could not assign element 'M' for Atom (name=MG) with given element 'M'\n  warnings.warn(msg, PDBConstructionWarning)\n28/07/2024 18:41:22 logger: ============&gt;chain 1 L and chain2 M\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Polypeptide.py:144: BiopythonDeprecationWarning: 'three_to_one' will be deprecated in a future release of Biopython in favor of 'Bio.PDB.Polypeptide.protein_letters_3to1'.\n  warnings.warn(\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Polypeptide.py:144: BiopythonDeprecationWarning: 'three_to_one' will be deprecated in a future release of Biopython in favor of 'Bio.PDB.Polypeptide.protein_letters_3to1'.\n  warnings.warn(\n28/07/2024 18:41:36 logger: ============&gt;chain 1 L and chain2 H\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Polypeptide.py:144: BiopythonDeprecationWarning: 'three_to_one' will be deprecated in a future release of Biopython in favor of 'Bio.PDB.Polypeptide.protein_letters_3to1'.\n  warnings.warn(\n28/07/2024 18:41:46 logger: ============&gt;chain 1 M and chain2 H\n       res_fas_id1 res1  res_pdb_id1  ...       dist chain1  chain2\n0                1    A            1  ...  33.363850      L       M\n1                1    A            1  ...  27.019474      L       M\n2                1    A            1  ...  29.652020      L       M\n3                1    A            1  ...  28.374273      L       M\n4                1    A            1  ...  29.460558      L       M\n...            ...  ...          ...  ...        ...    ...     ...\n74041          301    H          301  ...  61.372215      M       H\n74042          301    H          301  ...  64.072952      M       H\n74043          301    H          301  ...  62.540863      M       H\n74044          301    H          301  ...  60.712658      M       H\n74045          301    H          301  ...  65.942444      M       H\n\n[227753 rows x 9 columns]\n</code></pre></p> <p>Tip</p> <p>All chains of a protein can be seen by <code>pp.str.chains</code>.</p> <p> Python <pre><code>import pypropel as pp\n\nchains = pp.str.chains(\n    pdb_fp=to('data/pdb/complex/pdbtm/'),\n    pdb_name='1aij',\n)\nprint(chains)\n</code></pre></p> <p> Output <pre><code>['L', 'M', 'H']\n</code></pre></p>"},{"location":"tutorial/protein/distance/complex/#2_check_interaction","title":"2. Check interaction","text":"<p>It checks if a residue in the chain 1 has a minimum distance against all of residues in the chain 2. It stops the calculations of the minimum distance of each residue to each residue in the chain 2 when it detects a minimum distance of less than <code>thres</code>, 6 by default. <code>pp.dist.check_chain_complex</code> checks every two chains within a complex.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dist.check_chain_complex(\n    pdb_fp=to('data/pdb/complex/pdbtm/'),\n    prot_name='1aij',\n    sv_fp=to('data/pdb/complex/pdbtm/'),\n    thres=5.5,\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 19:57:40 logger: =========&gt;Protein PDB code: 1aij\nD:\\Programming\\anaconda3\\envs\\prot\\Lib\\site-packages\\Bio\\PDB\\Atom.py:232: PDBConstructionWarning: Could not assign element 'M' for Atom (name=MG) with given element 'M'\n  warnings.warn(msg, PDBConstructionWarning)\n28/07/2024 19:57:40 logger: =========&gt;Protein chain 1: L\n28/07/2024 19:57:40 logger: ============&gt;Protein chain 2: M\n28/07/2024 19:57:40 logger: ==================&gt;residue 1 ID: 0\n28/07/2024 19:57:40 logger: ==================&gt;residue 0 and residue 252 in interaction\n28/07/2024 19:57:40 logger: ============&gt;Protein chain 2: H\n28/07/2024 19:57:40 logger: ==================&gt;residue 1 ID: 0\n28/07/2024 19:57:40 logger: ==================&gt;residue 0 and residue 31 in interaction\n28/07/2024 19:57:40 logger: =========&gt;Protein chain 1: M\n28/07/2024 19:57:40 logger: ============&gt;Protein chain 2: H\n28/07/2024 19:57:40 logger: ==================&gt;residue 1 ID: 0\n28/07/2024 19:57:40 logger: ==================&gt;residue 0 and residue 186 in interaction\n28/07/2024 19:57:40 logger: =========&gt;Protein chain 1: H\n</code></pre></p> <p>The results are saved to the <code>1aij.ccheck</code> file. It has the following content. <pre><code>1aij    L\n1aij    M\n1aij    L\n1aij    H\n1aij    M\n1aij    H\n</code></pre></p>"},{"location":"tutorial/protein/distance/complex/#3_dist_file","title":"3. <code>dist</code> file","text":"<p>We can calculate the distance of a residue from a target protein away from residues from the rest of chains in the protein complex.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dist.complex_calc_all(\n    pdb_fp=to('data/pdb/complex/pdbtm/'),\n    prot_name='1aij',\n    prot_chain='L',\n    method='heavy',\n    sv_fp=to('data/pdb/complex/pdbtm/'),\n)\n</code></pre></p> <p>It returns a file <code>1aijL.dist</code>, having the following content.</p> <p> Output <pre><code>       0  1    2         M          H\n0      1  A    1  3.359507   3.820152\n1      2  L    2  4.832898   2.840868\n2      3  L    3  3.621853   3.450767\n3      4  S    4  6.046180   2.841488\n4      5  F    5  3.438960   3.688982\n..   ... ..  ...       ...        ...\n276  277  G  277  2.910155  43.177975\n277  278  G  278  3.036153  40.448544\n278  279  I  279  2.979592  36.381111\n279  280  N  280  2.980944  38.922234\n280  281  G  281  3.484761  42.785561\n\n[281 rows x 5 columns]\n</code></pre></p> <p>The above columns correspond to different items in the following table.</p> Column Description 0 fasta id 1 1 residue 1 2 pdb id 1 M chain 1 distance H chain 2 distance"},{"location":"tutorial/protein/distance/complex/#4_pdbinter_file","title":"4. <code>pdbinter</code> file","text":"<p>We can calculate the distance of a residue from a target protein away from residues from the rest of chains in the protein complex.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dist.complex_calc_all(\n    pdb_fp=to('data/pdb/complex/pdbtm/'),\n    prot_name='1aij',\n    prot_chain='L',\n    method='heavy',\n    sv_fp=to('data/pdb/complex/pdbtm/'),\n)\n</code></pre></p> <p>It returns a file <code>1aijL.pdbinter</code>, having the following content.</p> <p> Output <pre><code>L   1   A   M   253 R   3.3595068\nL   2   L   M   253 R   4.832898\nL   3   L   M   246 E   5.9632444\nL   3   L   M   249 A   4.6895933\nL   3   L   M   250 L   3.7801166\n...\nL   227 L   H   173 E   3.6427267\nL   227 L   H   175 M   3.9549832\nL   227 L   H   177 R   5.680695\nL   228 G   H   173 E   5.4361606\n\n[643 rows x 7 columns]\n</code></pre></p> <p>The above columns correspond to different items in the following table.</p> Column Description chain1 chain 1 pos1 pdb id 1 aa1 residue 1 chain2 chain 2 pos2 pdb id 2 aa2 residue 2 dist distance"},{"location":"tutorial/protein/distance/complex/#5_submission_to_the_server","title":"5. Submission to the server","text":"<p> Python <pre><code>import pypropel as pp\n\nfrom pypropel.util.Reader import Reader as pfreader\n\ndf = pfreader().generic(df_fpn=to('data/ex/final.txt'), header=0)\nprots = df.prot.unique()[2000:]\n\nparam_config = {\n    'pdb_fp': '-fp',\n    'pdb_fn': '-fn',\n    'sv_fp': '-op',\n}\nvalue_config = {\n    'tool_fp': '/path/to/python',\n    'script_fpn': './Complex.py',\n    'pdb_fp': '/path/to/protein complex files/',\n    'sv_fp': '/path/to/save/results/',\n}\n\nfor key, prot in enumerate(prots):\n    order_list = [\n        value_config['tool_fp'],\n        value_config['script_fpn'],\n\n        param_config['pdb_fp'], value_config['pdb_fp'],\n        param_config['pdb_fn'], prot,\n        param_config['sv_fp'], value_config['sv_fp'],\n    ]\n    pp.dist.cloud_check(\n        order_list=order_list,\n        job_fp='/path/to/save/job files/',\n        job_fn=str(key),\n        cpu=2,\n        memory=10,\n        method='script',\n        submission_method='sbatch',\n    )\n</code></pre></p> <p>Tip</p> <p>the <code>final.txt</code> file is obtained from running TMKit's <code>tmkit.collate</code> for a set of proteins.</p> <pre><code>Unnamed: 0  prot    chain   prot_mark   rez met bio_name    head    desc    mthm    seq_aa  seq_len nchain  met1\n0   2a06    C   2a06C   2.1 x-ray diffraction   bovine cytochrome bc1 complex with stigmatellin bound   oxidoreductase  OXIDOREDUCTASE  8   NNAFIDLPAPSNISSWWNFGSLLGICLILQILTGLFLAMHYTSDTTTAFSSVTHICRDVNYGWIIRYMHANGASMFFICLYMHVGRGLYYGSYTFLETWNIGVILLLTVMATAFMGYVLPWGQMSFWGATVITNLLSAIPYIGTNLVEWIWGGFSVDKATLTRFFAFHFILPFIIMAIAMVHLLFLHETGSNNPTGISSDVDKIPFHPYYTIKDILGALLLILALMLLVLFAPDLLGDPDNYTPANPLNTPPHIKPEWYFLFAYAILRSIPNKLGGVLALAFSILILALIPLLHTSKQRSMMFRPLSQCLFWALVADLLTLTWIGGQPVEHPYITIGQLASVLYFLLILVLMPTAGTIENKLLKW   365.0   20.0    x-ray diffraction\n4   2a06    P   2a06P   2.1     bovine cytochrome bc1 complex with stigmatellin bound   oxidoreductase  OXIDOREDUCTASE  8   LMKIVNNAFIDLPAPSNISSWWNFGSLLGICLILQILTGLFLAMHYTSDTTTAFSSVTHICRDVNYGWIIRYMHANGASMFFICLYMHVGRGLYYGSYTFLETWNIGVILLLTVMATAFMGYVLPWGQMSFWGATVITNLLSAIPYIGTNLVEWIWGGFSVDKATLTRFFAFHFILPFIIMAIAMVHLLFLHETGSNNPTGISSDVDKIPFHPYYTIKDILGALLLILALMLLVLFAPDLLGDPDNYTPANPLNTPPHIKPEWYFLFAYAILRSIPNKLGGVLALAFSILILALIPLLHTSKQRSMMFRPLSQCLFWALVADLLTLTWIGGQPVEHPYITIGQLASVLYFLLILVLMPTAGTIENKLLKW  370.0   20.0    x-ray diffraction\n77  4a01    A   4a01A   2.35    x-ray diffraction   crystal structure of the h-translocating pyrophosphatase    hydrolase   HYDROLASE   16  GAAILPDLGTEILIPVCAVIGIAFALFQWLLVSKVKLSAVDHNVVVKCAEIQNAISEGATSFLFTEYKYVGIFMVAFAILIFLFLGSVEGFSTSPQACSYDKTKTCKPALATAIFSTVSFLLGGVTSLVSGFLGMKIATYANARTTLEARKGVGKAFITAFRSGAVMGFLLAANGLLVLYIAINLFKIYYGDDWGGLFEAITGYGLGGSSMALFGRVGGGIYTKAADVGADLVGKVERNIPEDDPRNPAVIADNVGDNVGDIAGMGSDLFGSYAESSCAALVVASISSFGLNHELTAMLYPLIVSSVGILVCLLTTLFATDFFEIKAVKEIEPALKKQLVISTVLMTIGVAVVSFVALPTSFTIFNFGVQKDVKSWQLFLCVAVGLWAGLIIGFVTEYYTSNAYSPVQDVADSCRTGAATNVIFGLALGYKSVIIPIFAIAISIFVSFTFAAMYGIAVAALGMLSTIATGLAIDAYGPISDNAGGIAEMAGMSHRIRERTDALDAAGNTTAAIGKGFAIGSAALVSLALFGAFVSRASITTVDVLTPKVFIGLIVGAMLPYWFSAMTMKSVGSAALKMVEEVRRQFNTIPGLMEGTAKPDYATCVKISTDASIKEMIPPGALVMLTPLVVGILFGVETLSGVLAGSLVSGVQIAISASNTGGAWDNAKKYIEAGASEHARSLGPKGSDCHKAAVIGDTIGDPLKDTSGPSLNILIKLMAVESLVFAPFFATHGGLLFKIF    740.0   2.0 x-ray diffraction\n78  4a01    B   4a01B   2.35        crystal structure of the h-translocating pyrophosphatase    hydrolase   HYDROLASE   16  GAAILPDLGTEILIPVCAVIGIAFALFQWLLVSKVKLSAVDHNVVVKCAEIQNAISEGATSFLFTEYKYVGIFMVAFAILIFLFLGSVEGFSTSPQACSYDKTKTCKPALATAIFSTVSFLLGGVTSLVSGFLGMKIATYANARTTLEARKGVGKAFITAFRSGAVMGFLLAANGLLVLYIAINLFKIYYGDDWGGLFEAITGYGLGGSSMALFGRVGGGIYTKAADVGADLVGKVERNIPEDDPRNPAVIADNVGDNVGDIAGMGSDLFGSYAESSCAALVVASISSFGLNHELTAMLYPLIVSSVGILVCLLTTLFATDFFEIKAVKEIEPALKKQLVISTVLMTIGVAVVSFVALPTSFTIFNFGVQKDVKSWQLFLCVAVGLWAGLIIGFVTEYYTSNAYSPVQDVADSCRTGAATNVIFGLALGYKSVIIPIFAIAISIFVSFTFAAMYGIAVAALGMLSTIATGLAIDAYGPISDNAGGIAEMAGMSHRIRERTDALDAAGNTTAAIGKGFAIGSAALVSLALFGAFVSRASITTVDVLTPKVFIGLIVGAMLPYWFSAMTMKSVGSAALKMVEEVRRQFNTIPGLMEGTAKPDYATCVKISTDASIKEMIPPGALVMLTPLVVGILFGVETLSGVLAGSLVSGVQIAISASNTGGAWDNAKKYIEAGASEHARSLGPKGSDCHKAAVIGDTIGDPLKDTSGPSLNILIKLMAVESLVFAPFFATHGGLLFKIF    740.0   2.0 x-ray diffraction\n79  7a0w    A   7a0wA   2.04    x-ray diffraction   structure of dimeric sodium proton antiporter nhaa, at ph 8.5, crystallized with chimeric fab antibodies    membrane protein    MEMBRANE PROTEIN    12  ASGGIILIIAAALAMLMANMGATSGWYHDFLETPVQLRVGALEINKNMLLWINDALMAVFFLLIGLEVKRELMQGSLASLRQAAFPVIAAIGGMIVPALLYLAFNYSDPVTREGWAIPAATDIAFALGVLALLGSRVPLALKIFLMALAIIDDLGAIVIIALFYTSDLSIVSLGVAAFAIAVLALLNLCGVRRTGVYILVGAVLWTAVLKSGVHATLAGVIVGFFIPLKEKHGRSPAKRLEHVLHPWVAYLILPLFAFANAGVSLQGVTIDGLTSMLPLGIIAGLLIGKPLGISLFCWLALRFKLAHLPQGTTYQQIMAVGILCGIGFTMSIFIASLAFGNVDPELINWAKLGILIGSLLSAVVGYSW    368.0   2.0 x-ray diffraction\n</code></pre>"},{"location":"tutorial/protein/distance/screening/","title":"Screening","text":""},{"location":"tutorial/protein/distance/screening/#1_label_residues","title":"1. Label residues","text":"<p>The following code allows users to label residues as interation sites or non-interaction sites. The labels will be rendered as in column <code>is_contact</code>.</p> <p><code>dist_fp</code> will be the directory where the <code>*.dist</code> file is stored.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dist.labelling(\n    dist_fp=to('data/pdb/complex/pdbtm/'),\n    prot_name='1aij',\n    file_chain='L',\n    cutoff=6,\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 21:33:30 logger: ================&gt;Labeling data...\n28/07/2024 21:33:30 logger: ================&gt;Time to label distances 1aij L: 0.004000186920166016s.\n     fasta_id aa  pdb_id    dist_1     dist_2  is_contact\n0           1  A       1  3.359507   3.820152           1\n1           2  L       2  4.832898   2.840869           1\n2           3  L       3  3.621853   3.450767           1\n3           4  S       4  6.046180   2.841488           1\n4           5  F       5  3.438960   3.688982           1\n..        ... ..     ...       ...        ...         ...\n276       277  G     277  2.910155  43.177975           1\n277       278  G     278  3.036153  40.448544           1\n278       279  I     279  2.979592  36.381110           1\n279       280  N     280  2.980944  38.922234           1\n280       281  G     281  3.484761  42.785560           1\n\n[281 rows x 6 columns]\n</code></pre></p>"},{"location":"tutorial/protein/distance/screening/#2_find_interaction_partners","title":"2. Find interaction partners","text":"<p>The following code allows you to find the partner chains in interaction with the target protein chain within one protein complex.</p> <p> Python <pre><code>import pypropel as pp\n\npp.dist.interation_partners(\n    dist_fp=to('data/pdb/complex/pdbtm/'),\n    prot_name='1aij',\n    file_chain='L',\n    cutoff=6,\n    pdb_fp=to('data/pdb/complex/pdbtm/'),\n)\n</code></pre></p> <p>It will output the following list containing the partner chains interacting with chain <code>L</code> of protein <code>1aij</code>.</p> <p> Output <pre><code>['M', 'H']\n</code></pre></p>"},{"location":"tutorial/protein/evaluation/sitewise-prediction/","title":"Sitewise prediction","text":""},{"location":"tutorial/protein/evaluation/sitewise-prediction/#interaction_prediction","title":"Interaction prediction","text":"<p>Protein residue sites involved in interaction are functionally important for cellular activities. They are generally defined as spatially closed residues in a protein complex. It would be easiest to obtain information of interaction sites from a protein complex structure per se. Thus, there are plenty of literature and work carried out to develop interaction predictors. To evaluate their predictive abilities, we implemented a powerful module <code>pp.eval</code> to evaluate sitewise predictors (include but not limited to interaction predictors).</p> <p>We take protein <code>1aij</code> chain <code>L</code> as an example to evaluate an interaction site predictor, <code>tma300</code> in its transmembrane segments demarked by the PDBTM database. If you are not interested in transmembrane segments, you can set <code>segment</code> to <code>whole</code>.</p> <p> Python <pre><code>import pypropel as pp\nimport pandas as pd\n\nprot_df = pd.DataFrame({\n        'prot': ['1aij', ],\n        'chain': ['L', ],\n    })\n\npp.eval.sitewise_segment(\n    prot_df=prot_df,\n    dist_fp=to('data/pdb/complex/pdbtm/'),\n    dist_limit=6.,\n    tool_fp=to('data/isite/deeptminter/'),\n    tool='tma300',\n    pdb_fp=to('data/pdb/pdbtm/'),\n    topo_fp=to('data/phobius/'),\n    xml_fp=to('data/xml/'),\n    fasta_fp=to('data/fasta/'),\n    segment='pdbtm_tmh',\n    sort=1,\n    sv_fp=to('data/'),\n)\n</code></pre></p> <p> Output <pre><code>28/07/2024 22:48:41 logger: ================&gt;Labeling data...\n28/07/2024 22:48:41 logger: ================&gt;Time to label distances 1aij L: 0.00400090217590332s.\n=========&gt;Segment lower pdb id: [  1  50 106 131 150 164 190 248 259 268]\n=========&gt;Segment upper pdb id: [ 31  89 115 149 163 171 231 258 267 281]\n=========&gt;Segment lower fasta id: [1, 50, 106, 131, 150, 164, 190, 248, 259, 268]\n=========&gt;Segment upper fasta id: [31, 89, 115, 149, 163, 171, 231, 258, 267, 281]\n=========&gt;Segment lower pdb id: [ 32  90 116 172 232]\n=========&gt;Segment upper pdb id: [ 49 105 130 189 247]\n=========&gt;Segment lower fasta id: [32, 90, 116, 172, 232]\n=========&gt;Segment upper fasta id: [49, 105, 130, 189, 247]\n{'1aij_L': {83: 28, 42: 25, 17: 13, 8: 7}}\n</code></pre></p> <p>It results in 29 files for evaluation.</p> Fig 1. Files of multiple evaluation metrics"},{"location":"tutorial/protein/external/JSD/","title":"JSD","text":""},{"location":"tutorial/protein/external/JSD/#1_download_the_jsd_package","title":"1. Download the JSD package","text":"<p>The standalone package of JSD can be downloaded at https://compbio.cs.princeton.edu/conservation/. The JSD package uses the Jensen-Shannon divergence for computing residue conservation based on a MSA. </p> <p>Tip</p> <p>The JSD output can be used as a feature to describe residue evolutionary profile at each MSA column.</p>"},{"location":"tutorial/protein/external/JSD/#2_running_the_jsd_package","title":"2. Running the JSD package","text":"<p>We wrote a wrapper to use the package in computer clusters for batch processing of the MSA files. It takes as input MSAs in <code>clustal</code> format.</p> <p>Before using, we need to set a few parameters.</p> <pre><code>param_config = {\n    'method': '-s',\n    # 'window': '-w',\n    # 'distance': '-d',\n    'sv_fp': '-o',\n    'clustal_fp': '',\n}\n\nvalue_config = {\n    'tool_fp': 'python',\n    'method': 'js_divergence',\n    'window': '3',\n    'distance': 'swissprot.distribution',\n    'script_fpn': to('prot/feature/alignment/external/jsd/score_conservation.py'),\n    'clustal_fp': to('data/msa/clustal/wild/SR24_AtoI/'),\n    'sv_fp': to('data/jsd/SR24_AtoI/'),\n}\n</code></pre> <p>In <code>prot.txt</code>, there are 7 proteins</p> <pre><code>ATAD2_LOC113841329\nCAMK1G\nCYP2W1_LOC101804267\nKIF27\nKIF27_LOC113841629\nLOC119718710\nRBBP8NL\n</code></pre> <p>Then, we can use <code>pp.external.jsd</code> to running JSD for a set of proteins.</p> <pre><code>import pypropel as pp\n\nfrom pypropel.util.Reader import Reader as pfreader\ndf = pfreader().generic(df_fpn=to('data/msa/clustal/wild/SR24_AtoI/prot.txt'))\nprots = df[0].unique()\n\nfor key, prot in enumerate(prots):\n    order_list = [\n        value_config['tool_fp'],\n        value_config['script_fpn'],\n\n        param_config['method'], value_config['method'],\n        # param_config['window'], value_config['window'],\n        # param_config['distance'], value_config['distance'],\n        param_config['sv_fp'], value_config['sv_fp'] + prot + '.jsd',\n        param_config['clustal_fp'], value_config['clustal_fp'] + prot + '.clustal',\n    ]\n    pp.external.jsd(\n        order_list=order_list,\n        job_fp='./',\n        job_fn=str(key),\n    )\n</code></pre>"},{"location":"tutorial/protein/feature/composition/","title":"Composition","text":""},{"location":"tutorial/protein/feature/composition/#protein-level","title":"Protein-level","text":"<p>In PyPropel, the function <code>fpseq</code> governs the extraction of features from the whole proteins. At the protein level, PyPropel considers compositions of amino acids across the whole protein sequence. It can be done below.</p>"},{"location":"tutorial/protein/feature/composition/#aac","title":"AAC","text":"<p>AAC stands for the amino acid composition.</p> <p> Python <pre><code>import pypropel as pp\n\naac = pp.fpseq.composition(\n    seq=seq,\n    mode='aac',\n)\n</code></pre></p> <p> Output <pre><code>{'A': 0.119403, 'C': 0.074627, 'D': 0.149254, 'E': 0.089552, 'F': 0.059701, 'G': 0.089552, 'H': 0.0, 'I': 0.0, 'K': 0.014925, 'L': 0.029851, 'M': 0.044776, 'N': 0.029851, 'P': 0.029851, 'Q': 0.029851, 'R': 0.014925, 'S': 0.119403, 'T': 0.014925, 'V': 0.044776, 'W': 0.029851, 'Y': 0.014925}\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#dac","title":"DAC","text":"<p>DAC stands for the di-amino acid composition.</p> <p> Python <pre><code>import pypropel as pp\n\ndac = pp.msa.composition(\n    seq=seq,\n    mode='dac',\n)\n</code></pre></p> <p> Output <pre><code>[['AA', 0.015152], ['AC', 0.0], ['AD', 0.075758], ..., ['YW', 0.0], ['YY', 0.0]]\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#tac","title":"TAC","text":"<p>TAC stands for the tri-amino acid composition.</p> <p> Python <pre><code>import pypropel as pp\n\ntac = pp.msa.composition(\n    seq=seq,\n    mode='tac',\n)\n</code></pre></p> <p> Output <pre><code>[['AAA', 0.0], ['AAC', 0.0], ['AAD', 0.015385], ...]\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#qac","title":"QAC","text":"<p>QAC stands for the qua-amino acid composition.</p> <p> Python <pre><code>import pypropel as pp\n\nqac = pp.msa.composition(\n    seq=seq,\n    mode='qac',\n)\n</code></pre></p> <p> Output <pre><code>[['AAAA', 0.0], ['AAAC', 0.0], ['AAAD', 0.0], ...]\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#cksnap","title":"CKSNAP","text":"<p>CKSNAP measures the average frequencies of every two amino acids that are <code>k</code> spaced.</p> <p> Python <pre><code>import pypropel as pp\n\ncksnap = pp.msa.composition(\n    seq=seq,\n    k_spaced=3,\n    mode='cksnap',\n)\n</code></pre></p> <p> Output <pre><code>{'AA': 0.047619, 'AC': 0, 'AD': 0, 'AE': 0.015873, 'AF': 0, 'AG': 0.015873, 'AH': 0, 'AI': 0, 'AK': 0, 'AL': 0, 'AM': 0, 'AN': 0, 'AP': 0, 'AQ': 0, 'AR': 0, 'AS': 0.031746, 'AT': 0, 'AV': 0, 'AW': 0, 'AY': 0, 'CA': 0, 'CC': 0.015873, 'CD': 0.015873, 'CE': 0.015873, 'CF': 0, 'CG': 0, 'CH': 0, 'CI': 0, 'CK': 0.015873, 'CL': 0, 'CM': 0, 'CN': 0, 'CP': 0, 'CQ': 0, 'CR': 0, 'CS': 0, 'CT': 0, 'CV': 0.015873, 'CW': 0, 'CY': 0, 'DA': 0.015873, 'DC': 0, 'DD': 0.031746, 'DE': 0.015873, 'DF': 0, 'DG': 0, 'DH': 0, 'DI': 0, 'DK': 0, 'DL': 0.015873, 'DM': 0, 'DN': 0, 'DP': 0, 'DQ': 0, 'DR': 0, 'DS': 0.031746, 'DT': 0, 'DV': 0.015873, 'DW': 0.015873, 'DY': 0, 'EA': 0, 'EC': 0, 'ED': 0.015873, 'EE': 0, 'EF': 0.031746, 'EG': 0, 'EH': 0, 'EI': 0, 'EK': 0, 'EL': 0.015873, 'EM': 0, 'EN': 0, 'EP': 0, 'EQ': 0.015873, 'ER': 0, 'ES': 0, 'ET': 0, 'EV': 0, 'EW': 0, 'EY': 0, 'FA': 0.015873, 'FC': 0, 'FD': 0.031746, 'FE': 0, 'FF': 0, 'FG': 0, 'FH': 0, 'FI': 0, 'FK': 0, 'FL': 0, 'FM': 0, 'FN': 0.015873, 'FP': 0, 'FQ': 0, 'FR': 0, 'FS': 0, 'FT': 0, 'FV': 0, 'FW': 0, 'FY': 0, 'GA': 0, 'GC': 0, 'GD': 0, 'GE': 0, 'GF': 0, 'GG': 0.063492, 'GH': 0, 'GI': 0, 'GK': 0, 'GL': 0, 'GM': 0.015873, 'GN': 0.015873, 'GP': 0, 'GQ': 0, 'GR': 0, 'GS': 0, 'GT': 0, 'GV': 0, 'GW': 0, 'GY': 0, 'HA': 0, 'HC': 0, 'HD': 0, 'HE': 0, 'HF': 0, 'HG': 0, 'HH': 0, 'HI': 0, 'HK': 0, 'HL': 0, 'HM': 0, 'HN': 0, 'HP': 0, 'HQ': 0, 'HR': 0, 'HS': 0, 'HT': 0, 'HV': 0, 'HW': 0, 'HY': 0, 'IA': 0, 'IC': 0, 'ID': 0, 'IE': 0, 'IF': 0, 'IG': 0, 'IH': 0, 'II': 0, 'IK': 0, 'IL': 0, 'IM': 0, 'IN': 0, 'IP': 0, 'IQ': 0, 'IR': 0, 'IS': 0, 'IT': 0, 'IV': 0, 'IW': 0, 'IY': 0, 'KA': 0.015873, 'KC': 0, 'KD': 0, 'KE': 0, 'KF': 0, 'KG': 0, 'KH': 0, 'KI': 0, 'KK': 0, 'KL': 0, 'KM': 0, 'KN': 0, 'KP': 0, 'KQ': 0, 'KR': 0, 'KS': 0, 'KT': 0, 'KV': 0, 'KW': 0, 'KY': 0, 'LA': 0, 'LC': 0, 'LD': 0, 'LE': 0, 'LF': 0, 'LG': 0, 'LH': 0, 'LI': 0, 'LK': 0, 'LL': 0, 'LM': 0, 'LN': 0, 'LP': 0, 'LQ': 0, 'LR': 0, 'LS': 0.031746, 'LT': 0, 'LV': 0, 'LW': 0, 'LY': 0, 'MA': 0, 'MC': 0, 'MD': 0, 'ME': 0, 'MF': 0, 'MG': 0, 'MH': 0, 'MI': 0, 'MK': 0, 'ML': 0, 'MM': 0.015873, 'MN': 0, 'MP': 0, 'MQ': 0, 'MR': 0, 'MS': 0, 'MT': 0, 'MV': 0, 'MW': 0.015873, 'MY': 0.015873, 'NA': 0, 'NC': 0, 'ND': 0, 'NE': 0, 'NF': 0.015873, 'NG': 0, 'NH': 0, 'NI': 0, 'NK': 0, 'NL': 0, 'NM': 0.015873, 'NN': 0, 'NP': 0, 'NQ': 0, 'NR': 0, 'NS': 0, 'NT': 0, 'NV': 0, 'NW': 0, 'NY': 0, 'PA': 0, 'PC': 0.015873, 'PD': 0, 'PE': 0, 'PF': 0, 'PG': 0, 'PH': 0, 'PI': 0, 'PK': 0, 'PL': 0, 'PM': 0, 'PN': 0, 'PP': 0, 'PQ': 0.015873, 'PR': 0, 'PS': 0, 'PT': 0, 'PV': 0, 'PW': 0, 'PY': 0, 'QA': 0, 'QC': 0.031746, 'QD': 0, 'QE': 0, 'QF': 0, 'QG': 0, 'QH': 0, 'QI': 0, 'QK': 0, 'QL': 0, 'QM': 0, 'QN': 0, 'QP': 0, 'QQ': 0, 'QR': 0, 'QS': 0, 'QT': 0, 'QV': 0, 'QW': 0, 'QY': 0, 'RA': 0, 'RC': 0, 'RD': 0, 'RE': 0, 'RF': 0, 'RG': 0, 'RH': 0, 'RI': 0, 'RK': 0, 'RL': 0, 'RM': 0, 'RN': 0, 'RP': 0, 'RQ': 0, 'RR': 0, 'RS': 0.015873, 'RT': 0, 'RV': 0, 'RW': 0, 'RY': 0, 'SA': 0.015873, 'SC': 0, 'SD': 0.015873, 'SE': 0.031746, 'SF': 0, 'SG': 0, 'SH': 0, 'SI': 0, 'SK': 0, 'SL': 0, 'SM': 0, 'SN': 0, 'SP': 0.015873, 'SQ': 0, 'SR': 0, 'SS': 0.015873, 'ST': 0, 'SV': 0.015873, 'SW': 0, 'SY': 0, 'TA': 0, 'TC': 0, 'TD': 0, 'TE': 0, 'TF': 0, 'TG': 0, 'TH': 0, 'TI': 0, 'TK': 0, 'TL': 0, 'TM': 0, 'TN': 0, 'TP': 0.015873, 'TQ': 0, 'TR': 0, 'TS': 0, 'TT': 0, 'TV': 0, 'TW': 0, 'TY': 0, 'VA': 0, 'VC': 0, 'VD': 0, 'VE': 0.015873, 'VF': 0.015873, 'VG': 0, 'VH': 0, 'VI': 0, 'VK': 0, 'VL': 0, 'VM': 0, 'VN': 0, 'VP': 0, 'VQ': 0, 'VR': 0, 'VS': 0, 'VT': 0.015873, 'VV': 0, 'VW': 0, 'VY': 0, 'WA': 0, 'WC': 0, 'WD': 0.015873, 'WE': 0, 'WF': 0, 'WG': 0, 'WH': 0, 'WI': 0, 'WK': 0, 'WL': 0, 'WM': 0, 'WN': 0, 'WP': 0, 'WQ': 0, 'WR': 0.015873, 'WS': 0, 'WT': 0, 'WV': 0, 'WW': 0, 'WY': 0, 'YA': 0, 'YC': 0, 'YD': 0.015873, 'YE': 0, 'YF': 0, 'YG': 0, 'YH': 0, 'YI': 0, 'YK': 0, 'YL': 0, 'YM': 0, 'YN': 0, 'YP': 0, 'YQ': 0, 'YR': 0, 'YS': 0, 'YT': 0, 'YV': 0, 'YW': 0, 'YY': 0}\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#aveanf","title":"AVEANF","text":"<p>The AVEANF feature reflects the information about positions and frequencies of amino acids in a protein sequence. For details, please refer to <sup>1</sup></p> <p> Python <pre><code>import pypropel as pp\n\naveanf = pp.msa.composition(\n    seq=seq,\n    mode='aveanf',\n)\n</code></pre></p> <p> Output <pre><code>{'A': 0.22597633674152806, 'C': 0.1652824858757062, 'D': 0.17214478688616622, 'E': 0.09744508222164794, 'F': 0.0459034244741305, 'G': 0.4204055204055204, 'H': 0, 'I': 0, 'K': 0.045454545454545456, 'L': 0.03737373737373738, 'M': 0.10492898913951544, 'N': 0.04793028322440087, 'P': 0.055322128851540614, 'Q': 0.059848484848484845, 'R': 0.017857142857142856, 'S': 0.08590396237795747, 'T': 0.1, 'V': 0.10087719298245613, 'W': 0.04096989966555184, 'Y': 0.04}\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#msa-level","title":"MSA-level","text":"<p>First, we can read a MSA of protein <code>1aijL</code> as follows.</p> <p> Python <pre><code>import pypropel as pp\n\nmsa = pp.msa.read(\n    msa_fpn=to('data/msa/aln/1aijL.aln'),\n)\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#aac_1","title":"AAC","text":"<p>Then, the AAC of MSA is calculated below.</p> <p> Python <pre><code>import pypropel as pp\n\naac = pp.msa.composition(\n    msa=msa,\n    mode='aac',\n)\n</code></pre></p> <p> Output <pre><code>{'A': 0.05826085292688736, 'C': 0.004700385606685579, 'D': 0.008600878716107662, 'E': 0.015672130729309737, 'F': 0.05294113895278523, 'G': 0.06534156201388167, 'H': 0.019759785927038455, 'I': 0.04494023459261235, 'K': 0.0027040633087310126, 'L': 0.05968535215833517, 'M': 0.022540825417799226, 'N': 0.01639108826946766, 'P': 0.03155605592517563, 'Q': 0.011760641022454832, 'R': 0.017077715813173088, 'S': 0.03935616241622517, 'T': 0.02184298134471232, 'V': 0.040838283818220966, 'W': 0.01871466930702302, 'Y': 0.0222107075628659, '-': 0.42443809036607894}\n</code></pre></p>"},{"location":"tutorial/protein/feature/composition/#site-level","title":"Site-level","text":"<p>There is no method to calculate compositions of amino acids because no accurate einformation can be reflected from a site itself in a protein sequence given only.</p> <ol> <li> <p>Zhen Chen, Pei Zhao, Fuyi Li, Tatiana T Marquez-Lago, Andr\u00e9 Leier, Jerico Revote, Yan Zhu, David R Powell, Tatsuya Akutsu, Geoffrey I Webb, Kuo-Chen Chou, A Ian Smith, Roger J Daly, Jian Li, Jiangning Song, iLearn: an integrated platform and meta-learner for feature engineering, machine-learning analysis and modeling of DNA, RNA and protein sequence data, Briefings in Bioinformatics, Volume 21, Issue 3, May 2020, Pages 1047\u20131057, https://doi.org/10.1093/bib/bbz041\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/conservation/","title":"Conservation","text":""},{"location":"tutorial/protein/feature/conservation/#entropy","title":"Entropy","text":"<p>In the context of multiple sequence alignments (MSA), entropy measures the variability or uncertainty at each position in the alignment. It quantifies how conserved or variable a particular position is across the aligned sequences, offering insight into which positions are likely to be functionally or structurally important.</p> <p>We can first read a MSA in ALN format with <code>pp.msa.msaparser</code>. Then, taking this MSA as input to <code>pp.fpmsa.entropy</code>, we obtain a dictionary of entropy values.</p> <p> Python <pre><code>import pypropel as pp\n\nmsa = pp.msa.msaparser(msa_fpn=to('data/msa/aln/1aijL.aln')).read()\n\nentropy_dict = pp.fpmsa.entropy(msa=msa)\n\nprint(entropy_dict)\n</code></pre></p> <p> Output <pre><code>{1: 0.1960388659924533, 2: 0.22426701608683547, 3: 0.1850087818623904, 4: 0.20286277711377826, 5: 0.18773405896608028, 6: 0.18177904812214024, 7: 0.22124858188044072, 8: 0.1964272886606503, 9: 0.18956787701644068, 10: 0.19008797269348587, ..., 279: 0.07534724091084649, 280: 0.07102837084165835, 281: 0.06073066166727346}\n</code></pre></p> <p>If we want to consider the information from a gap symbol '-', we can achieve it with <code>pp.fpmsa.entropy_gap</code>.</p> <p> Python <pre><code>import pypropel as pp\n\nentropy_dict = pp.fpmsa.entropy_gap(msa=msa, gap_thres=100)\n\nprint(entropy_dict)\n</code></pre></p> <p> Output <pre><code>{1: 0.3256135083150946, 2: 0.3724994507477074, 3: 0.30729293513478106, ..., 279: 0.12514905822699368, 280: 0.11797557031649158, 281: 0.10087144560680732}\n</code></pre></p>"},{"location":"tutorial/protein/feature/conservation/#custom-conservation","title":"Custom-conservation","text":"<p>We borrow a technical idea from <sup>1</sup> to build a custom-conservation score based on the above calculated entropy values.</p> <p> Python <pre><code>import pypropel as pp\n\ncc = pp.fpmsa.conservation_custom(ent_dict=entropy_dict)\n\nprint(cc)\n</code></pre></p> <p> Output <pre><code>{1: 0.891307540667243, 2: 0.8756566285859075, 3: 0.8974230982362708, ..., 279: 0.9582242180545316, 280: 0.9606187871466461, 281: 0.9663282842404544}\n</code></pre></p>"},{"location":"tutorial/protein/feature/conservation/#mutual_information","title":"Mutual information","text":"<p>Mutual information (MI) is an information theory metric that quantifies how much information one random variable reveals about another. In the context of multiple sequence alignments (MSA), MI measures the statistical dependency between sequence positions, helping to identify co-evolving residues. </p> <p>To calculate the MI between columns 1 and 2, we can do</p> <p> Python <pre><code>import pypropel as pp\n\nmsa = pp.msa.msaparser(msa_fpn=to('data/msa/aln/1aijL.aln')).read()\n\nmi = pp.fpmsa.mutual_information(msa=msa, i=1, j=2)\n\nprint(mi)\n</code></pre></p> <p> Output <pre><code>0.20924659742293167\n</code></pre></p>"},{"location":"tutorial/protein/feature/conservation/#jensenshannon_divergence","title":"Jensen\u2013Shannon Divergence","text":"<p>Jensen\u2013Shannon Divergence (JSD) <sup>2</sup> is a useful metric in structual bioinformatics for evaluating the conservation of sequence positions in multiple sequence alignments (MSAs). By analyzing the distribution of amino acids or nucleotides at each position, JSD helps to identify conserved and variable regions, indicating areas of functional or structural significance.</p> <p>A JSD file looks like <pre><code># ./CLEC2B_LOC113845378.clustal -- js_divergence - window_size: 3 - window lambda: 0.50 - background: blosum62 - seq. weighting: True - gap penalty: 1 - normalized: False\n        # align_column_number   score   column\n        0   -1000.000000    M-M-M-T----TET--TTTMM-M-----------------------------------------------------P-----------------------------------------------\n        1   -1000.000000    E-S-D-Q----QTE--QQQEE-E-----------------------------------------------------V----------------------G------------------------\n        2   -1000.000000    K-S-S-N----DGY--DNNPP-P-----------------------------------------------------P----------------------P------------------------\n        3   -1000.000000\n        ...\n        205 -1000.000000    PN---S---P--VPF------R---------------L---LL---LLL------L----DD---V----A--E----------------------------------EME---L-EE-I----\n        206 -1000.000000    EP---P---R---VP----------------------S---SS---SSS------S----HH---T----E--K----------------------------------SCS---C-SS-M----\n</code></pre></p> <p> Python <pre><code>import pypropel as pp\n\njsd = pp.fpmsa.jsd(\n    fpn=to('data/conservation/jsd/SR24_CtoU/CLEC2B_LOC113845378.jsd'),\n    mode='standalone',\n)\nprint(jsd)\n</code></pre></p> <p>The <code>standalone</code> mode means the output returned from running its standalone package.</p> <p> Output <pre><code>     alignment_col  score                                                seq\n0                0    0.0  M-M-M-T----TET--TTTMM-M-----------------------...\n1                1    0.0  E-S-D-Q----QTE--QQQEE-E-----------------------...\n2                2    0.0  K-S-S-N----DGY--DNNPP-P-----------------------...\n3                3    0.0  E-E-E-E----EEN--EEEAA-A-----------------------...\n4                4    0.0  V-N-N-G----EKN--EGG---------------------------...\n..             ...    ...                                                ...\n202            202    0.0  KL---T---G--TTT------E-P---------D--DEGDDEES--...\n203            203    0.0  II---P---S--PPP------Y-L---------S--SQ-QSRRK--...\n204            204    0.0  SV---F---V--PVF------M-L-------------F-S-LL---...\n205            205    0.0  PN---S---P--VPF------R---------------L---LL---...\n206            206    0.0  EP---P---R---VP----------------------S---SS---...\n\n[207 rows x 3 columns]\n</code></pre></p>"},{"location":"tutorial/protein/feature/conservation/#consurf","title":"ConSurf","text":"<p>ConSurf <sup>3</sup> is designed to identify and visualize conserved regions within protein or nucleic acid sequences. By mapping conservation levels onto the three-dimensional structure of a protein, ConSurf aids in pinpointing functionally and structurally significant regions.</p> <p>We tease out the information from it by</p> <p> Python <pre><code>import pypropel as pp\n\nconsurf = pp.fpmsa.consurf(\n    fpn=to('data/conservation/consurf/E.consurf'),\n    mode='v1'\n)\nprint(consurf)\n</code></pre></p> <p>The <code>v1</code> mode means the output adopted by ConSurf before 2024.</p> <p> Output <pre><code>    position amino acid  score color exposed/buried structral/functional\n0          1          M -1.409     9              e                    f\n1          2          Y  0.136    5*              e                     \n2          3          S -0.426     6              e                     \n3          4          F -0.115     5              b                     \n4          5          V -1.201     8              b                     \n..       ...        ...    ...   ...            ...                  ...\n70        71          P  0.637    3*              e                     \n71        72          D  0.109    5*              e                     \n72        73          L -0.200    6*              b                     \n73        74          L -0.120    5*              e                     \n74        75          V -0.991     8              e                    f\n\n[75 rows x 6 columns]\n</code></pre></p> <p>The original output of ConSurf of E protein is <pre><code>    0  1       2  3   4              5  6   ...   8  9  10 11 12      13         14\n0    1  M  -1.409      9  -1.875,-1.232     ...  9,8        e  f  78/150        M,N\n1    2  Y   0.136     5*  -0.618, 0.577     ...  7,3        e     78/150    C,F,Y,L\n2    3  S  -0.426      6  -1.003,-0.074     ...  8,5        e     78/150  E,P,S,Y,D\n3    4  F  -0.115      5  -0.776, 0.279     ...  7,4        b     78/150      I,F,L\n4    5  V  -1.201      8  -1.582,-0.928     ...  9,7        b     78/150      V,F,Q\n..  .. ..     ... ..  ..            ... ..  ...  ... .. .. .. ..     ...        ...\n70  71  P   0.637     3*  -0.365, 1.225     ...  6,2        e     34/150      S,P,L\n71  72  D   0.109     5*  -0.776, 0.755     ...  7,3        e     34/150        D,E\n72  73  L  -0.200     6*  -1.003, 0.419     ...  8,4        b     34/150        L,F\n73  74  L  -0.120     5*  -1.003, 0.419     ...  8,4        e     34/150        I,L\n74  75  V  -0.991      8  -1.582,-0.618     ...  9,7        e  f  33/150          V\n\n[75 rows x 15 columns]\n</code></pre></p> <p>The columns from the left to the right are defined as:</p> <p>Column definition</p> <pre><code>- POS: The position of the AA in the SEQRES derived sequence.\n- SEQ: The SEQRES derived sequence in one letter code.\n- SCORE: The normalized conservation scores.\n- COLOR: The color scale representing the conservation scores (9 - conserved, 1 - variable).\n- CONFIDENCE INTERVAL: When using the bayesian method for calculating rates, a confidence interval is assigned to each of the inferred evolutionary conservation scores.\n- CONFIDENCE INTERVAL COLORS: When using the bayesian method for calculating rates. The color scale representing the lower and upper bounds of the confidence interval.\n- B/E: Burried (b) or Exposed (e) residue.\n- FUNCTION: functional (f) or structural (s) residue (f - highly conserved and exposed, s - highly conserved and burried).\n- MSA DATA: The number of aligned sequences having an amino acid (non-gapped) from the overall number of sequences at each position.\n- RESIDUE VARIETY: The residues variety at each position of the multiple sequence alignment.\n</code></pre> <ol> <li> <p>Zeng B, H\u00f6nigschmid P, Frishman D. Residue co-evolution helps predict interaction sites in \u03b1-helical membrane proteins. J Struct Biol. 2019 May 1;206(2):156-169. doi: 10.1016/j.jsb.2019.02.009. Epub 2019 Mar 2. PMID: 30836197. https://doi.org/10.1016/j.jsb.2019.02.009\u00a0\u21a9</p> </li> <li> <p>John A. Capra, Mona Singh, Predicting functionally important residues from sequence conservation, Bioinformatics, Volume 23, Issue 15, August 2007, Pages 1875\u20131882, https://doi.org/10.1093/bioinformatics/btm270\u00a0\u21a9</p> </li> <li> <p>Barak Yariv, Elon Yariv, Amit Kessel, Gal Masrati, Adi Ben Chorin, Eric Martz, Itay Mayrose, Tal Pupko, and Nir Ben-Tal Using evolutionary data to make sense of macromolecules with a 'face-lifted' ConSurf. Protein Science 2023; DOI: 10.1002/pro.4582; PMID: 36718848. https://doi.org/10.1002/pro.4582\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/length/","title":"Length","text":""},{"location":"tutorial/protein/feature/length/#sequence","title":"Sequence","text":"<p><code>pp.fpseq.length</code> is used to measure the length of a protein sequence. There are two options: <code>log</code> and <code>normal</code>.</p> <p> Python <pre><code>import pypropel as pp\n\nl = pp.fpseq.length(\n    seq=seq,\n    mode='normal',\n)\nprint(l)\n</code></pre></p> <p> Output <pre><code>67\n</code></pre></p> <p>You can get a log-normalised length value by <pre><code>mode='log',\n</code></pre></p> <p> Output <pre><code>4.204692619390966\n</code></pre></p>"},{"location":"tutorial/protein/feature/length/#msa","title":"MSA","text":"<p>We can use PyPropel to count the homologs of a MSA.</p> <p> Python <pre><code>import pypropel as pp\n\nmsa = pp.msa.read(msa_fpn=to('data/msa/aln/1aijL.aln'))\n\nl = pp.fpmsa.length(\n    msa=msa,\n)\nprint(l)\n</code></pre></p> <p> Output <pre><code>16181\n</code></pre></p>"},{"location":"tutorial/protein/feature/position/","title":"Position","text":""},{"location":"tutorial/protein/feature/position/#absolute_position","title":"Absolute position","text":"<p>We can use PyPropel to calculate the positional features of a residue in a protein.</p> <p>First, PyPropel needs to read a protein sequence like below.</p> <p> Python <pre><code>import pypropel as pp\n\nseq = pp.seq.read(\n    fasta_fpn=to('data/fasta/1aigL.fasta'),\n)\nprint(seq)\n</code></pre></p> <p> Output <pre><code>ALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n</code></pre></p> <p>Then, we use <code>pp.fpsite.pos_abs_val</code> to calculate a residue positioned at 1 in the protein.</p> <p> Python <pre><code>import pypropel as pp\n\np = pp.fpsite.pos_abs_val(\n    pos=1,\n    seq=sequence,\n)\nprint(p)\n</code></pre></p> <p> Output <pre><code>0.0035587189\n</code></pre></p>"},{"location":"tutorial/protein/feature/position/#relative_position","title":"Relative position","text":"<p>We implement a function to calculate the positional feature of a residue relative to the transmembrane segment, proposed by Zeng et al <sup>1</sup>, which is to calculate the position of a residue relative to the boundary of a transmembrane segment (interval).</p> <p> Python <pre><code>import pypropel as pp\n\npos = pp.fpsite.pos_rel_val(\n    pos=5,\n    interval=[4, 10],\n)\nprint(pos)\n</code></pre></p> <p> Output <pre><code>0.16666666666666666\n</code></pre></p>"},{"location":"tutorial/protein/feature/position/#one-hot_position","title":"One-hot position","text":"<p>In addition, positions of residues can be one-hot encoded to describe their rough positional occurrence in the protein. There are two residue contact prediction tools that use this idea.</p>"},{"location":"tutorial/protein/feature/position/#metapsicov","title":"MetaPSICOV","text":"<p> Python <pre><code>import pypropel as pp\n\npos = pp.fpsite.metapsicov()\nprint(pos)\n</code></pre></p> <p> Output <pre><code>{\n    'v&lt;5': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n    'v=5': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],\n    'v=6': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n    'v=7': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n    'v=8': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n    'v=9': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'v=10': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'v=11': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'v=12': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'v=13': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '14&lt;=v&lt;18': [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '18&lt;=v&lt;23': [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '23&lt;=v&lt;28': [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '28&lt;=v&lt;38': [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '38&lt;=v&lt;48': [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'v&gt;=48': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'none': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n}\n</code></pre></p>"},{"location":"tutorial/protein/feature/position/#deepconpred","title":"DeepConPred","text":"<p> Python <pre><code>import pypropel as pp\n\npos = pp.fpsite.deepconpred()\nprint(pos)\n</code></pre></p> <p> Output <pre><code>{\n    '24&lt;=v&lt;=28': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n\n    '29&lt;=v&lt;=33': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0],\n    '34&lt;=v&lt;=38': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n    '39&lt;=v&lt;=43': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n    '44&lt;=v&lt;=48': [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n    '49&lt;=v&lt;=58': [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '59&lt;=v&lt;=68': [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '69&lt;=v&lt;=78': [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    '79&lt;=v&lt;=88': [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'v&gt;=89': [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n    'none': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n}\n</code></pre></p> <ol> <li> <p>Zeng B, H\u00f6nigschmid P, Frishman D. Residue co-evolution helps predict interaction sites in \u03b1-helical membrane proteins. J Struct Biol. 2019 May 1;206(2):156-169. doi: 10.1016/j.jsb.2019.02.009. Epub 2019 Mar 2. PMID: 30836197. https://doi.org/10.1016/j.jsb.2019.02.009\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/profile/","title":"Profile","text":"<p>Position-Specific Scoring Matrix (PSSM) is a matrix used to score alignments between a protein sequence (cf. DNA and RNA) and a profile, which is a representation of a multiple sequence alignment. Each score indicates the likelihood of a specific nucleotide or amino acid occurring at a particular position in the sequence. There are many models to calculate it.</p>"},{"location":"tutorial/protein/feature/profile/#blast","title":"Blast","text":"<p>The Basic local alignment search tool (Blast) <sup>1</sup> can be used to generate one kind of the PSSM. It can be accessed like that below.</p> <p> Python <pre><code>import pypropel as pp\n\naac = pp.fpmsa.pssm(\n    fpn=to('data/pssm/1aigL.pssm'),\n    mode='blast',\n)\n</code></pre></p> <p> Output <pre><code>{1: [-5.0, 1.0, 3.0, 2.0, 3.0, 1.0, 3.0, 2.0, 2.0, 3.0, 2.0, 2.0, 2.0, 2.0, 2.0, -1.0, -1.0, 1.0, 4.0, 3.0], 2: [2.0, 2.0, 4.0, 3.0, 1.0, 2.0, 3.0, -2.0, 2.0, -3.0, -6.0, 3.0, 3.0, 1.0, 1.0, 2.0, -0.0, -1.0, 3.0, 2.0], ...}\n</code></pre></p>"},{"location":"tutorial/protein/feature/profile/#hhm","title":"HHM","text":"<p>HHM is created by profile hidden Markov models (HMMs). The <code>.hhm</code> file is generated by HHblits<sup>2</sup>. It measures PSSM about how conserved each amino acid is at each column in a MSA.</p> <p> Python <pre><code>import pypropel as pp\n\naac = pp.fpmsa.pssm(\n    fpn=to('data/hhm/1aigL.hhm'),\n    mode='hhm',\n)\n</code></pre></p> <p> Output <pre><code>{1: array([1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ,\n       0. , 0. , 0. , 0. , 0. , 0. , 0. , 1. , 0. , 0. , 0. , 0. , 0. ,\n       0. , 0.5, 1. , 1. ]), 2: array([0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 1. , 0. , 0. , 0. ,\n       0. , 0. , 0. , 0. , 0. , 0. , 0. , 1. , 0. , 0. , 0. , 0. , 0. ,\n       0. , 0.5, 1. , 1. ]), ...}\n</code></pre></p>"},{"location":"tutorial/protein/feature/profile/#evolutionary_profile","title":"Evolutionary profile","text":"<p>Evolutionary profile is calculated as frequencies of amino acids at each MSA column <sup>2</sup>.</p> <p> Python <pre><code>import pypropel as pp\n\nep = pp.fpmsa.pssm(\n    msa=msa,\n    mode='ep',\n)\n</code></pre></p> <p> Output <pre><code>{'A': array([8.25272552e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 5.30380817e-03, 0.00000000e+00,\n       0.00000000e+00, 1.06076163e-03, ..., 3.18228490e-03, 1.16683780e-02,\n       1.06076163e-03]), 'C': array([0.00000000e+00, ...\n</code></pre></p> <p>You can pass <code>ep_norm</code> onto <code>mode</code> to get the normalised evolutionary profile.</p> <pre><code>mode='ep_norm'\n</code></pre> <ol> <li> <p>Altschul, S.F., Gish, W., Miller, W., Myers, E.W., Lipman, D.J. (1990) \u201cBasic local alignment search tool.\u201d J. Mol. Biol. 215:403-410. https://doi.org/10.1016/S0022-2836(05)80360-2\u00a0\u21a9</p> </li> <li> <p>H\u00f6nigschmid P, Frishman D. Accurate prediction of helix interactions and residue contacts in membrane proteins. J Struct Biol. 2016 Apr;194(1):112-23. doi: 10.1016/j.jsb.2016.02.005. Epub 2016 Feb 3. PMID: 26851352.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/property/","title":"Property","text":"<p>We use 23 indicators to describe physicochemical properties of amino acids as shown in Table 1. You can use <code>pp.fpsite.property</code> to get access to them.</p> <p> Python <pre><code>import pypropel as pp\n\nproperty = 'positive'\n\nscale = pp.fpsite.property(property)\n\nprint(scale)\n</code></pre></p> <p> Output <pre><code>{'A': 1.0, 'C': 1.0, 'D': 1.0, 'E': 1.0, 'F': 1.0, 'G': 1.0, 'H': 0.5, 'I': 1.0, 'K': 0.0, 'L': 1.0, 'M': 1.0, 'N': 1.0, 'P': 1.0, 'Q': 1.0, 'R': 0.0, 'S': 1.0, 'T': 1.0, 'V': 1.0, 'W': 1.0, 'Y': 1.0}\n</code></pre></p> <p>In fact, <code>property</code> can be any of 23 amino acid properties, including</p> <p>Table 1. amino acid properties</p> Property Kind Citation Value positive <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete negative <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete charged <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete polar <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete aliphatic <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete aromatic <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete hydrophobic <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete small <code>Russell</code> Betts &amp; Russell<sup>1</sup> discrete active <code>Russell</code> Betts &amp; Russell<sup>1</sup> continuous weight <code>Taylor</code> Lundblad &amp; Macdonald<sup>2</sup> continuous pI <code>Taylor</code> Lundblad &amp; Macdonald<sup>2</sup> continuous solubility <code>Taylor</code> Lundblad &amp; Macdonald<sup>2</sup> continuous tm <code>Taylor</code> Lundblad &amp; Macdonald<sup>2</sup> continuous pka <code>Taylor</code> Lundblad &amp; Macdonald<sup>2</sup> continuous pkb <code>Taylor</code> Lundblad &amp; Macdonald<sup>2</sup> continuous hydrophilicity <code>Hopp</code> <sup>3</sup> discrete hydrophobicity <code>Argos</code> Argos et al.<sup>4</sup> continuous fet <code>Argos</code> Argos et al.<sup>4</sup> continuous hydration <code>Argos</code> Argos et al.<sup>4</sup> continuous signal <code>Argos</code> Argos et al.<sup>4</sup> continuous volume <code>Grantham</code> Grantham <sup>5</sup> continuous polarity <code>Grantham</code> Grantham <sup>5</sup> continuous composition <code>Grantham</code> Grantham <sup>5</sup> continuous <p>Note</p> <p>pI: pH at the isoelectric point.</p> <p>Solubility in water in units of grams of compound per kilogram of water.</p> <p>tm: Melting point.</p> <p>pKa: Negative of the logarithm of the acid dissociation constants for the COOH and NH2 groups (and, in some cases, other groups) in the molecule (at 25\u00b0C)</p> <ol> <li> <p>Betts, M.J. and Russell, R.B. (2003). Amino Acid Properties and Consequences of Substitutions. In Bioinformatics for Geneticists (eds M.R. Barnes and I.C. Gray). https://doi.org/10.1002/0470867302.ch14\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Lundblad, R.L., &amp; Macdonald, F. (Eds.). (2018). Handbook of Biochemistry and Molecular Biology (5th ed.). CRC Press. https://doi.org/10.1201/b21846\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Hopp TP, Woods KR. Prediction of protein antigenic determinants from amino acid sequences. Proc Natl Acad Sci U S A. 1981 Jun;78(6):3824-8. doi: 10.1073/pnas.78.6.3824.\u00a0\u21a9</p> </li> <li> <p>ARGOS, P., RAO, J.K.M. and HARGRAVE, P.A. (1982), Structural Prediction of Membrane-Bound Proteins. European Journal of Biochemistry, 128: 565-575. https://doi.org/10.1111/j.1432-1033.1982.tb07002.x\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>R. Grantham ,Amino Acid Difference Formula to Help Explain Protein Evolution.Science185,862-864(1974).DOI:10.1126/science.185.4154.862\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/rsa/","title":"Rsa","text":""},{"location":"tutorial/protein/feature/rsa/#relative_solvent_accessibility","title":"Relative solvent accessibility","text":"<p>Relative solvent accessibility (RSA) is a metric used in structural biology to quantify the extent to which an amino acid residue in a protein is exposed to solvent, typically water. RSA offers insights into the environmental context of the residue and its potential functional roles within the protein structure.</p> <p>PyPropel can access the RSA of 2 methods, <code>solvpred</code><sup>1</sup> and <code>accpro</code><sup>2</sup>.</p>"},{"location":"tutorial/protein/feature/rsa/#solvpred","title":"solvpred","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.rsa_solvpred(\n    solvpred_fp=to('data/accessibility/solvpred/'),\n    prot_name='1aig',\n    file_chain='L',\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>       0  1      2\n0      1  A  0.855\n1      2  L  0.458\n2      3  L  0.308\n3      4  S  0.420\n4      5  F  0.219\n..   ... ..    ...\n276  277  G  0.397\n277  278  G  0.336\n278  279  I  0.215\n279  280  N  0.548\n280  281  G  0.912\n\n[281 rows x 3 columns]\n</code></pre></p>"},{"location":"tutorial/protein/feature/rsa/#accpro","title":"accpro","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.rsa_accpro(\n    accpro_fp=to('data/accessibility/accpro/'),\n    prot_name='1aig',\n    file_chain='L',\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>     0\n0    e\n1    -\n2    -\n3    -\n4    -\n..  ..\n276  e\n277  e\n278  e\n279  e\n280  e\n\n[281 rows x 1 columns]\n</code></pre></p>"},{"location":"tutorial/protein/feature/rsa/#accpro20","title":"accpro20","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.rsa_accpro20(\n    accpro20_fp=to('data/accessibility/accpro20/'),\n    prot_name='1aig',\n    file_chain='L',\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>        0\n0    0.30\n1    0.00\n2    0.00\n3    0.05\n4    0.00\n..    ...\n276  0.35\n277  0.30\n278  0.45\n279  0.35\n280  0.90\n\n[281 rows x 1 columns]\n</code></pre></p> <ol> <li> <p>Jones DT. Protein secondary structure prediction based on position-specific scoring matrices. J Mol Biol. 1999 Sep 17;292(2):195-202. doi: 10.1006/jmbi.1999.3091. PMID: 10493868.\u00a0\u21a9</p> </li> <li> <p>Urban G, Magnan CN, Baldi P. SSpro/ACCpro 6: almost perfect prediction of protein secondary structure and relative solvent accessibility using profiles, deep learning and structural similarity. Bioinformatics. 2022 Mar 28;38(7):2064-2065. doi: 10.1093/bioinformatics/btac019. PMID: 35108364.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/secondary-structure/","title":"Secondary structure","text":""},{"location":"tutorial/protein/feature/secondary-structure/#relative_solvent_accessibility","title":"Relative solvent accessibility","text":"<p>Secondary structure prediction methods are used to predict the local structures that form within a protein, specifically alpha helices, beta strands, and loops or turns. These predictions are essential for understanding protein function and guiding experimental structure determination.</p> <p>Secondary Structures:</p> <ol> <li>Alpha Helices: Coiled structures stabilized by hydrogen bonds between the backbone atoms.</li> <li>Beta Strands: Extended strands that can form hydrogen bonds with neighboring strands to create a sheet-like arrangement.</li> <li>Loops/Turns: Irregular, flexible regions that connect helices and strands.</li> </ol> <p>PyPropel can handle the output of 3 secondary structure prediction methods, <code>PSIPRED</code><sup>1</sup>, <code>SSpro</code><sup>2</sup>, and <code>Spider3</code><sup>3</sup>.</p>"},{"location":"tutorial/protein/feature/secondary-structure/#psipred","title":"PSIPRED","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.ss_psipred(\n    psipred_path=to('data/ss/psipred/'),\n    prot_name='1aig',\n    file_chain='L',\n    kind='ss', # horiz, ss, ss2\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>       0  1  2      3      4      5\n0      1  A  C  0.992  0.003  0.004\n1      2  L  C  0.697  0.082  0.148\n2      3  L  C  0.684  0.150  0.112\n3      4  S  C  0.673  0.121  0.155\n4      5  F  C  0.363  0.245  0.198\n..   ... .. ..    ...    ...    ...\n276  277  G  C  0.806  0.137  0.082\n277  278  G  C  0.765  0.123  0.104\n278  279  I  C  0.733  0.113  0.133\n279  280  N  C  0.825  0.088  0.068\n280  281  G  C  0.997  0.003  0.002\n\n[281 rows x 6 columns]\n</code></pre></p>"},{"location":"tutorial/protein/feature/secondary-structure/#sspro","title":"SSpro","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.ss_sspro(\n    sspro_path=to('data/ss/sspro/'),\n    prot_name='1aig',\n    file_chain='L'\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>     0\n0    C\n1    E\n2    C\n3    C\n4    C\n..  ..\n276  C\n277  C\n278  C\n279  C\n280  C\n</code></pre></p>"},{"location":"tutorial/protein/feature/secondary-structure/#sspro8","title":"SSpro8","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.rsa_accpro20(\n    accpro20_fp=to('data/accessibility/accpro20/'),\n    prot_name='1aig',\n    file_chain='L',\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>     0\n0    C\n1    B\n2    C\n3    T\n4    T\n..  ..\n276  S\n277  S\n278  S\n279  C\n280  C\n\n[281 rows x 1 columns]\n</code></pre></p>"},{"location":"tutorial/protein/feature/secondary-structure/#sspro8_1","title":"SSpro8","text":"<p> Python <pre><code>import pypropel as pp\n\ndf = pp.fpsite.rsa_accpro20(\n    accpro20_fp=to('data/accessibility/accpro20/'),\n    prot_name='1aig',\n    file_chain='L',\n)\nprint(df)\n</code></pre></p> <p> Output <pre><code>0     C\n1     C\n2     C\n3     C\n4     C\n     ..\n70    C\n71    C\n72    C\n73    C\n74    C\nName: SS, Length: 75, dtype: object\n</code></pre></p> <p>The original output of Spider3 contains multiple columns to describe protein properties. <code>P(C)</code>, <code>P(H)</code>, and <code>P(E)</code> are three columns are predicted probabilities of three types of secondary structures <code>C</code>, <code>H</code>, and <code>E</code>.</p> <pre><code>     # SEQ SS    ASA    Phi  ...  HSE_beta_down     CN   P(C)   P(H)   P(E)\n0    1   M  C  1.578 -0.945  ...          0.046  0.085  0.980  0.019  0.001\n1    2   Y  C  1.640 -0.993  ...          0.038  0.098  0.931  0.060  0.009\n2    3   S  C  0.873 -0.817  ...          0.102  0.144  0.868  0.127  0.005\n3    4   F  C  1.542 -0.857  ...          0.068  0.120  0.744  0.253  0.004\n4    5   V  C  1.032 -0.892  ...          0.070  0.124  0.620  0.377  0.003\n..  ..  .. ..    ...    ...  ...            ...    ...    ...    ...    ...\n70  71   P  C  0.940 -0.679  ...          0.099  0.159  0.843  0.148  0.008\n71  72   D  C  1.142 -0.741  ...          0.113  0.157  0.726  0.243  0.031\n72  73   L  C  1.205 -0.820  ...          0.060  0.126  0.708  0.245  0.047\n73  74   L  C  1.180 -0.859  ...          0.075  0.139  0.824  0.109  0.068\n74  75   V  C  1.153 -0.910  ...          0.075  0.150  0.983  0.006  0.011\n\n[75 rows x 16 columns]\n</code></pre> <ol> <li> <p>Jones DT. Protein secondary structure prediction based on position-specific scoring matrices. J Mol Biol. 1999 Sep 17;292(2):195-202. doi: 10.1006/jmbi.1999.3091. PMID: 10493868.\u00a0\u21a9</p> </li> <li> <p>Urban G, Magnan CN, Baldi P. SSpro/ACCpro 6: almost perfect prediction of protein secondary structure and relative solvent accessibility using profiles, deep learning and structural similarity. Bioinformatics. 2022 Mar 28;38(7):2064-2065. doi: 10.1093/bioinformatics/btac019. PMID: 35108364.\u00a0\u21a9</p> </li> <li> <p>Jack Hanson, Kuldip Paliwal, Thomas Litfin, Yuedong Yang, Yaoqi Zhou, Improving prediction of protein secondary structure, backbone angles, solvent accessibility and contact numbers by using predicted contact maps and an ensemble of recurrent and residual convolutional neural networks, Bioinformatics, Volume 35, Issue 14, July 2019, Pages 2403\u20132410, https://doi.org/10.1093/bioinformatics/bty1006\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature/structure/","title":"Structure","text":"<p>Features extracted based on 3D protein structures (or PDB files) are informative to characterise proteins. After loads of protein structures predicted by AlphaFold, AlphaFold2, and AlphaFold3 are made available online, the functions embedded in computational tools to access these structural features are necessary.</p> <p>Warning</p> <p>PyPropel is endeavouring to make the extraction of more structure-based features available. Currently, we include relative solvent accessibility (RSA) by DSSP and encoded sequences by the 3di technique.</p>"},{"location":"tutorial/protein/feature/structure/#relative_solvent_accessibility","title":"Relative solvent accessibility","text":"<p>Here, we take six proteins as an example to generate their RSA files using DSSP. It can be done as follows.</p> <p> Python <pre><code>import pandas as pd\n\nprot_df = pd.DataFrame({\n    'prot': ['3pux', '3rko', '3udc', '3vr8', '4kjs', '4pi2', ],\n    'chain': ['G', 'A', 'A', 'D', 'A', 'C', ],\n})\n</code></pre></p> <p> Python <pre><code>import pypropel as pp\n\nfor i in prot_df.index:\n    print('No.{}: protein: {} chain: {}'.format(i + 1, prot_df.loc[i, 'prot'], prot_df.loc[i, 'chain']))\n    dssp_rsa_run(\n        prot_name=prot_df.loc[i, 'prot'],\n        prot_chain=prot_df.loc[i, 'chain'],\n        pdb_fp='data/pdb/pdbtm/',\n        sv_fp='data/rsa/',\n    )\n</code></pre></p> <p>Then, we can access the RSA file of each protein.</p> <p> Python <pre><code>import pypropel as pp\nimport pandas as pd\n\nprot_df = pd.DataFrame({\n    'prot': ['3pux', '3rko', '3udc', '3vr8', '4kjs', '4pi2', ],\n    'chain': ['G', 'A', 'A', 'D', 'A', 'C', ],\n})\nfor i in prot_df.index:\n    print('No.{}: protein: {} chain: {}'.format(i + 1, prot_df.loc[i, 'prot'], prot_df.loc[i, 'chain']))\n    df_rsa = dssp_rsa_access(\n        prot_name=prot_df.loc[i, 'prot'],\n        prot_chain=prot_df.loc[i, 'chain'],\n        rsa_fp=to('data/rsa/')\n    )\n    print(df_rsa)\n</code></pre></p> <p> Output <pre><code>No.1: protein: 3pux chain: G\n     rsa_fas_id  rsa_pdb_ids  rsa_prob\n0             1            2  1.000000\n1             2            3  0.829787\n2             3            4  1.000000\n3             4            5  0.696970\n4             5            6  0.705882\n..          ...          ...       ...\n288         289          292  1.000000\n289         290          293  0.547619\n290         291          294  0.394366\n291         292          295  1.000000\n292         293          296  1.000000\n\n[293 rows x 3 columns]\nNo.2: protein: 3rko chain: A\n    rsa_fas_id  rsa_pdb_ids  rsa_prob\n0            1           15  1.000000\n1            2           16  0.695431\n2            3           17  0.528302\n3            4           18  0.668639\n4            5           19  0.690355\n..         ...          ...       ...\n90          91          122  0.018868\n91          92          123  0.682927\n92          93          124  0.687117\n93          94          125  0.731278\n94          95          126  0.823944\n\n[95 rows x 3 columns]\nNo.3: protein: 3udc chain: A\n     rsa_fas_id  rsa_pdb_ids  rsa_prob\n0             1           13  1.000000\n1             2           14  0.760736\n2             3           15  0.804734\n3             4           16  0.556098\n4             5           17  0.650943\n..          ...          ...       ...\n262         263          275  0.974522\n263         264          276  0.969543\n264         265          277  0.917073\n265         266          278  0.911290\n266         267          279  1.000000\n\n[267 rows x 3 columns]\nNo.4: protein: 3vr8 chain: D\n     rsa_fas_id  rsa_pdb_ids  rsa_prob\n0             1           28  1.000000\n1             2           29  0.861538\n2             3           30  0.915094\n3             4           31  0.933962\n4             5           32  0.985915\n..          ...          ...       ...\n124         125          152  0.468085\n125         126          153  0.570423\n126         127          154  0.863436\n127         128          155  0.804124\n128         129          156  1.000000\n\n[129 rows x 3 columns]\nNo.5: protein: 4kjs chain: A\n     rsa_fas_id  rsa_pdb_ids  rsa_prob\n0             1            4  0.840237\n1             2            5  0.456853\n2             3            6  0.720812\n3             4            7  0.698225\n4             5            8  0.408537\n..          ...          ...       ...\n315         316          347  0.380952\n316         317          348  0.035533\n317         318          349  0.461929\n318         319          350  0.798780\n319         320          351  0.756098\n\n[320 rows x 3 columns]\nNo.6: protein: 4pi2 chain: C\n     rsa_fas_id  rsa_pdb_ids  rsa_prob\n0             1           16  0.938144\n1             2           17  0.561538\n2             3           18  0.211268\n3             4           19  0.676056\n4             5           20  0.441718\n..          ...          ...       ...\n223         224          252  0.556098\n224         225          253  0.695122\n225         226          254  0.914634\n226         227          255  0.732394\n227         228          256  0.958763\n\n[228 rows x 3 columns]\n</code></pre></p>"},{"location":"tutorial/protein/feature/structure/#3di_encoded_sequence","title":"3di encoded sequence","text":"<p>3Di-encoded sequences refer to sequences encoded with 3D structural information of biomolecules, often proteins, to integrate their three-dimensional spatial features into a simplified format suitable for computational analysis, such as machine learning.</p> <p>This encoding bridges the gap between a protein's primary sequence (linear amino acid sequence) and its three-dimensional conformation (folded structure). The goal of 3Di encoding is to capture spatial relationships, structural motifs, and functional regions that are critical for biological activity.</p> <p>Includes 3D spatial features derived from the protein's folded structure, typically obtained from crystallography, NMR, or computational modeling (e.g. Angles and torsions: Phi (\u03d5), Psi (\u03c8), and Omega (\u03c9) angles).</p> <p>Here, we take 3 proteins as an example to generate their 3di.</p> <p> Python <pre><code>import pypropel as pp\nimport pandas as pd\n\nprot_df = pd.DataFrame({\n    'prot': ['1aij', '1aig', '1xqf', ],\n    'chain': ['L', 'L', 'A', ],\n})\nfor i in prot_df.index:\n    print('No.{}: protein: {} chain: {}'.format(i + 1, prot_df.loc[i, 'prot'], prot_df.loc[i, 'chain']))\n    threedi_dict = pp.fpstr.threedi(\n        prot_name=prot_df.loc[i, 'prot'],\n        prot_chain=prot_df.loc[i, 'chain'],\n        pdb_fp=to('data/pdb/pdbtm/'),\n        mode='chain',\n    )\n    print(threedi_dict)\n</code></pre></p> <p> Output <pre><code>No.1: protein: 1aij chain: L\n{'1aij': {'L': {'state': masked_array(data=[--, 2, 2, 12, 12, 5, 12, 17, 9, 9, 2, 0, 2, 9, 0, 12, 12, 2, 5, 1, 12, 13, 15, ..., 12, 14, --],\nmask=[ True, False, False, False, False, False, False, False,\nFalse, False, False, False, ..., False, False, False, True],\nfill_value=2,\ndtype=uint8), 'encoded_sequence': 'DDDPPGPVLLDADLAPPDGCPQSQADVPHRAGPLNVQLVVLVVVLVVLLVVLCVVVPHDDQQPRKQAAAPCVQFPHADDSNRHNSVVSSVVSVLRNQLSVLVSLSSVCSSVVHDSLPSVLSVLVSVLLCLQQPLLSVLLRHRRSHFMDGDVRSVVSVVVLCPQQPNVCLQVLLVLLVVLVVVLVVLVVLVVVLQVCQQPPPPPDDRHDQVVSQVVCCVVPNGDCGPVRSVVSNSVSNSSSSVSSSVSSSCDNNVDRHRSVVVVCVVCCPPPNVPDDDDPRD'}}}\nNo.2: protein: 1aig chain: L\n{'1aig': {'L': {'state': masked_array(data=[--, 2, 2, 12, ..., 2, 2, 11, --],\nmask=[ True, False, False, ..., False, False, False,\nTrue],\nfill_value=2,\ndtype=uint8), 'encoded_sequence': 'DDDPPCVVLLDADQADPDHCPQQDDDVPHGQGPLNVQLVVLVVVLVVLLVVQCVVVPHDDQQPSKQAAADPVCWADADDPNNHRSSVSSVVSVLSNQLSVLVVVSSVCRSVVHDSPVSVLSVLVSVLQCLQQPVLSVLLGHNRSHFMPGDVRSVVSVVVQCPLQPNVCLQVLLVVLVVLVVVLVVLVVVVVVLQCCQQVPPPPDDRHDQVVSQVVCCVVPVGDCGPVSSVVSNSCSSSSSSVSNSVSVSCEPRVDRHRSVVVCCCVQCVPPNNPDDDDDND'}}}\nNo.3: protein: 1xqf chain: A\n{'1xqf': {'A': {'state': masked_array(data=[--, 0, 0, ..., 14, 7,\n5, 2, --],\nmask=[ True, False, False, ..., False,\nFalse,  True],\nfill_value=2,\ndtype=uint8), 'encoded_sequence': 'DAADVQLQVLLVVLLVLLLLLQVPQLLLQLLQQDDVVQNVQLVVLLVVVLVVLLVVLQQAQVQFQAACDAQFTHDRPQGNHPPQDQRDDDPRHGVVSVSSNVSSLLSVLLSLQSSVCSVWWDSVLSVLLSVLCSVQALRRLSCNCPRPHVLVVLQAFFQQCLLNRQQLSLLLNVVVVVCHNHLVSSVVSLVSNLRSLLSRQLCSVSGPDVLSVQLNLLLVQLLVLQLVLQQVVCCVPVVGGDSVSSSQSSLQSSSLCRRARSWAGSVLSNVSSNVSSNQLNVQLVVVSSVSSSSNRSSLSSLQSNLPGSPVVNGTVHGPPPDDSVSNNVSSVVSSVVSNVSSNVSSVVSSVVSCVPPRIGDD'}}}\n</code></pre></p>"},{"location":"tutorial/protein/feature-vector/pairwise-site/","title":"Pairwise site","text":"<p>We will need to install TMKit<sup>1</sup> to read a protein sequence and create single-site positions, placed with windows. This will initiate the vector of features, and be prepared for being fed by site-wise features.</p> <p>After installation, we first read <code>1aigL.fasta</code>.</p> <p> Python <pre><code>import tmkit as tmk\n\nsequence = sfasta().get(\n    fasta_fpn=to(\"data/fasta/1aigL.fasta\")\n)\nprint(sequence)\n</code></pre></p> <p> Output <pre><code>ALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n</code></pre></p> <p>Generation of all posible residue pairs</p> <p> Python <pre><code>pos_list = tmk.seq.pos_list_pair(\n    len_seq=len(sequence),\n    seq_sep_superior=None,\n    seq_sep_inferior=0,\n)\nprint(pos_list)\n</code></pre></p> <p> Output <pre><code>[\n    [1, 2],\n    [1, 3],\n    [1, 4],\n    ...,\n    [279, 281],\n    [280, 281],\n]\n</code></pre></p> <p>Adding amino acid types and IDs to the positions of all posible residue pairs.</p> <p> Python <pre><code>positions = tmk.seq.pos_pair(sequence=sequence, pos_list=pos_list)\nprint(positions)\n</code></pre></p> <p> Output <pre><code>[\n    [1, 'A', 1, 2, 'L', 2, 0],\n    [1, 'A', 1, 3, 'L', 3, 0],\n    [1, 'A', 1, 4, 'S', 4, 0],\n    ...,\n    [279, 'I', 279, 281, 'G', 281, 0],\n    [280, 'N', 280, 281, 'G', 281, 0],\n]\n</code></pre></p> <p>Applying a sliding window to each residue pair.</p> <p> Python <pre><code>window_size = 1\nwin_aa_ids = tmk.seq.win_id_pair(\n    sequence=sequence,\n    position=positions,\n    window_size=window_size,\n)\nprint(win_aa_ids[:3])\n</code></pre></p> <p> Output <pre><code>[\n    [[None, 1, 2], [1, 2, 3]],\n    [[None, 1, 2], [2, 3, 4]],\n    [[None, 1, 2], [3, 4, 5]],\n    ...,\n    [[278, 279, 280], [280, 281, None]],\n    [[279, 280, 281], [280, 281, None]],\n]\n</code></pre></p> <p> Python <pre><code>win_aas = tmk.seq.win_name_single(\n    sequence=sequence,\n    position=positions,\n    window_size=1,\n    mids=win_aa_ids,\n)\nprint(win_aas)\n</code></pre></p> <p> Output <pre><code>[\n    [None, 'A', 'A', 'L', 'L', 'L'],\n    [None, 'L', 'A', 'L', 'L', 'S'],\n    [None, 'L', 'A', 'S', 'L', 'F'],\n    ...,\n    ['G', 'N', 'I', 'G', 'N', None],\n    ['I', 'N', 'N', 'G', 'G', None],\n]\n</code></pre></p> <p>Initiating feature vector.</p> <p> Python <pre><code>features = [[] for i in range(len(win_aa_ids))]\nprint(features)\nprint(len(features))\n</code></pre></p> <p> Output <pre><code>[[], [], [], [], ..., [], [], []]\n39340\n</code></pre></p> <ol> <li> <p>Jianfeng Sun, Arulsamy Kulandaisamy, Jinlong Ru, M Michael Gromiha, Adam P Cribbs, TMKit: a Python interface for computational analysis of transmembrane proteins, Briefings in Bioinformatics, Volume 24, Issue 5, September 2023, bbad288, https://doi.org/10.1093/bib/bbad288\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature-vector/single-site/","title":"Single site","text":"<p>We will need to install TMKit<sup>1</sup> to read a protein sequence and create single-site positions, placed with windows. This will initiate the vector of features, and be prepared for being fed by site-wise features.</p> <p>After installation, we first read <code>1aigL.fasta</code>.</p> <p> Python <pre><code>import tmkit as tmk\n\nsequence = tmk.seq.read_from_fasta(\n    fasta_fpn='./data/fasta/1xqfA.fasta'\n)\nprint(sequence)\n</code></pre></p> <p> Output <pre><code>ALLSFERKYRVPGGTLVGGNLFDFWVGPFYVGFFGVATFFFAALGIILIAWSAVLQGTWNPQLISVYPPALEYGLGGAPLAKGGLWQIITICATGAFVSWALREVEICRKLGIGYHIPFAFAFAILAYLTLVLFRPVMMGAWGYAFPYGIWTHLDWVSNTGYTYGNFHYNPAHMIAISFFFTNALALALHGALVLSAANPEKGKEMRTPDHEDTFFRDLVGYSIGTLGIHRLGLLLSLSAVFFSALCMIITGTIWFDQWVDWWQWWVKLPWWANIPGGING\n</code></pre></p> <p>Generation of all posible residues.</p> <p> Python <pre><code>pos_list = tmk.seq.pos_list_single(\n    len_seq=len(sequence),\n    seq_sep_superior=None,\n    seq_sep_inferior=0,\n)\nprint(pos_list)\n</code></pre></p> <p> Output <pre><code>[\n    [1],\n    [2],\n    [3],\n    ...,\n    [280],\n    [281],\n]\n</code></pre></p> <p>Adding amino acid types and IDs to the positions of all posible residues.</p> <p> Python <pre><code>positions = tmk.seq.pos_single(sequence=sequence, pos_list=pos_list)\nprint(positions)\n</code></pre></p> <p> Output <pre><code>[\n    [1, 'A', 1, 0],\n    [2, 'L', 2, 0],\n    [3, 'L', 3, 0],\n    ...,\n    [280, 'N', 280, 0],\n    [281, 'G', 281, 0],\n]\n</code></pre></p> <p>Applying a sliding window to each residue pair.</p> <p> Python <pre><code>win_aa_ids = tmk.seq.win_id_single(\n    sequence=sequence,\n    position=positions,\n    window_size=1,\n)\nprint(win_aa_ids)\n</code></pre></p> <p> Output <pre><code>[\n    [None, 1, 2],\n    [1, 2, 3],\n    [2, 3, 4],\n    ..., \n    [279, 280, 281],\n    [280, 281, None],\n]\n</code></pre></p> <p> Python <pre><code>win_aas = tmk.seq.win_name_single(\n    sequence=sequence,\n    position=positions,\n    window_size=1,\n    mids=win_aa_ids,\n)\nprint(win_aas)\n</code></pre></p> <p> Output <pre><code>[\n    [None, 'A', 'L'],\n    ['A', 'L', 'L'],\n    ['L', 'L', 'S'],\n    ...,\n    ['G', 'I', 'N'],\n    ['I', 'N', 'G'],\n    ['N', 'G', None],\n]\n</code></pre></p> <p>Initiating feature vector.</p> <p> Python <pre><code>features = [[] for i in range(len(sequence))]\nprint(features)\nprint(len(features))\n</code></pre></p> <p> Output <pre><code>[[], [], [], ..., [], [], []]\n281\n</code></pre></p> <ol> <li> <p>Jianfeng Sun, Arulsamy Kulandaisamy, Jinlong Ru, M Michael Gromiha, Adam P Cribbs, TMKit: a Python interface for computational analysis of transmembrane proteins, Briefings in Bioinformatics, Volume 24, Issue 5, September 2023, bbad288, https://doi.org/10.1093/bib/bbad288\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/feature-vector/whole-protein/","title":"Whole protein","text":"<p>Different from the site-wise feature vector, protein-level feature vector can be easily initiated by the following code if we know the number of the total number of samples for machine learning.</p> <pre><code>num_samples = 10000\n\nfeatures = [[] for _ in range(num_samples)]\n</code></pre>"},{"location":"tutorial/protein/plot/evaluation/","title":"Evaluation","text":"<p>Plotting evaluation metrics, such as ROCPR, are important for understanding predictive ability. In the current version, we can use PyPropel to draw ROCPR curves.</p> <p>We use interaction predicted probabilities by the <code>tma300</code> tool.</p> <p><code>tma300_roc_fpr_custom.json</code> contains false positive rate (FPR) and <code>tma300_roc_tpr_custom.json</code> contains true positive rate (TPR).</p> <p> Python <pre><code>import pypropel as pp\n\nX_fpns = {\n    'tma300': to('data/eval/tma300/tma300_roc_fpr_custom.json'),\n}\nY_fpns = {\n    'tma300': to('data/eval/tma300/tma300_roc_tpr_custom.json'),\n}\n\nfig, ax = plt.subplots(\n    nrows=2,\n    ncols=2,\n    # figsize=(6, 5),\n    figsize=(12, 10),\n    sharey='all',\n    sharex=False,\n)\npp.plot.rocpr(\n    X_fpns,\n    Y_fpns,\n    x_label='fpr',\n    y_label='tpr',\n    title='',\n    ax=ax[0, 0],\n)\npp.plot.rocpr(\n    X_fpns,\n    Y_fpns,\n    x_label='fpr',\n    y_label='tpr',\n    title='',\n    ax=ax[0, 1],\n)\npp.plot.rocpr(\n    X_fpns,\n    Y_fpns,\n    x_label='fpr',\n    y_label='tpr',\n    title='',\n    ax=ax[1, 0],\n)\nplt.show()\n</code></pre></p> Fig 1. ROCPR curves"},{"location":"tutorial/protein/plot/evolution/","title":"Evolution","text":"<p>We plot the results from three tools, <code>GraphPPIsv2</code><sup>1</sup>, <code>JSD</code><sup>2</sup>, and <code>MutPred2</code><sup>3</sup>, to understand the evolution of residues from MSAs of 7 example proteins, that is,</p> <pre><code>ATAD2_LOC113841329\nCYP2W1_LOC101804267\nKIF27\nKIF27_LOC113841629\nLOC119718710\nRBBP8NL\nCAMK1G\n</code></pre>"},{"location":"tutorial/protein/plot/evolution/#graphppisv2","title":"GraphPPIsv2","text":"<p>GraphPPIsv2 is used to draw the interaction profile of residues.</p> <p> Python <pre><code>import pypropel as pp\n\npp.plot.isite(\n    method='graphppis',\n    isite_fpns={\n        'ATAD2_LOC113841329': to('data/isite/graphppis/SR24_AtoI/ATAD2_LOC113841329.txt'),\n        'CYP2W1_LOC101804267': to('data/isite/graphppis/SR24_AtoI/CYP2W1_LOC101804267.txt'),\n        'KIF27': to('data/isite/graphppis/SR24_AtoI/KIF27.txt'),\n        'KIF27_LOC113841629': to('data/isite/graphppis/SR24_AtoI/KIF27_LOC113841629.txt'),\n        'LOC119718710': to('data/isite/graphppis/SR24_AtoI/LOC119718710.txt'),\n        'RBBP8NL': to('data/isite/graphppis/SR24_AtoI/RBBP8NL.txt'),\n        'CAMK1G': to('data/isite/graphppis/SR24_AtoI/RBBP8NL.txt'),\n    },\n    cmap='coolwarm',\n    sv_fpn=\"./A2I_ppi.pdf\",  # A2I_ppi C2U_ppi\n)\n</code></pre></p> Fig 1. Interaction profile of residues"},{"location":"tutorial/protein/plot/evolution/#jsd","title":"JSD","text":"<p>JSD is used to draw the conservation profile of residues.</p> <p> Python <pre><code>import pypropel as pp\n\npp.plot.conservation(\n    method='jsd',\n    conser_fpns={\n        'ATAD2_LOC113841329': to('data/conservation/jsd/SR24_AtoI/ATAD2_LOC113841329.jsd'),\n        'CAMK1G': to('data/conservation/jsd/SR24_AtoI/CAMK1G.jsd'),\n        'CYP2W1_LOC101804267': to('data/conservation/jsd/SR24_AtoI/CYP2W1_LOC101804267.jsd'),\n        'KIF27': to('data/conservation/jsd/SR24_AtoI/KIF27.jsd'),\n        'KIF27_LOC113841629': to('data/conservation/jsd/SR24_AtoI/KIF27_LOC113841629.jsd'),\n        'LOC119718710': to('data/conservation/jsd/SR24_AtoI/LOC119718710.jsd'),\n        'RBBP8NL': to('data/conservation/jsd/SR24_AtoI/RBBP8NL.jsd'),\n    },\n    cmap='CMRmap_r',\n    sv_fpn=\"./A2I_conser.pdf\", # A2I_conser C2U_conser\n)\n</code></pre></p> Fig 2. Conservation profile of residues"},{"location":"tutorial/protein/plot/evolution/#mutpred2","title":"MutPred2","text":"<p>MutPred2 is used to draw the mutational profile of residues.</p> <p> Python <pre><code>import pypropel as pp\n\npp.plot.mutpred2(\n    fpn=to('data/mutpred2.xlsx'),\n    sheet_name='SR24_CtoU',  # SR24_AtoI SR24_CtoU\n    title='SR24_CtoU',  # SR24_AtoI SR24_CtoU\n)\n</code></pre></p> Fig 3. Mutational profile of residues <ol> <li> <p>Qianmu Yuan, Jianwen Chen, Huiying Zhao, Yaoqi Zhou, Yuedong Yang, Structure-aware protein\u2013protein interaction site prediction using deep graph convolutional network, Bioinformatics, Volume 38, Issue 1, January 2022, Pages 125\u2013132, https://doi.org/10.1093/bioinformatics/btab643\u00a0\u21a9</p> </li> <li> <p>John A. Capra, Mona Singh, Predicting functionally important residues from sequence conservation, Bioinformatics, Volume 23, Issue 15, August 2007, Pages 1875\u20131882, https://doi.org/10.1093/bioinformatics/btm270\u00a0\u21a9</p> </li> <li> <p>Pejaver, V., Urresti, J., Lugo-Martinez, J. et al. Inferring the molecular and phenotypic impact of amino acid variants with MutPred2. Nat Commun 11, 5918 (2020). https://doi.org/10.1038/s41467-020-19669-x\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/protein/plot/interaction/","title":"Interaction","text":"<p>We try to find the relationship between the number of interaction sites in proteins and their interaction partners. An example file is <code>ex.txt</code>. It looks like</p> <pre><code>prot_name   chain_name  num_db  num_ip\n1fft    A   273 3\n1fft    B   314 2\n1fft    C   0   2\n...\n3d31    C   0   2\n3eam    A   1   2\n</code></pre> <p>Info</p> <p>num_db: number of interaction sites from databases. num_ip: number of interaction partners.</p> <p> Python <pre><code>import pypropel as pp\n\nfrom pypropel.util.Reader import Reader as pfreader\ndf = pfreader().generic(to('data/binning/ex.txt'), header=0)\nprint(df)\n\nfig, axes = plt.subplots(nrows=2, ncols=1, figsize=(6, 4), sharey=False, sharex='all')\npp.plot.binning(\n    df=df,\n    key='num_db',\n    num_bins=10,\n    ax=axes[0],\n).draw()\npp.plot.binning(\n    df=df,\n    key='num_ip',\n    num_bins=10,\n    ax=axes[1],\n).draw()\nplt.show()\n</code></pre></p> Fig 1. Binning of interaction sites and partners"},{"location":"tutorial/protein/uniprot/extract-information/","title":"Extract information","text":""},{"location":"tutorial/protein/uniprot/extract-information/#from_text","title":"From text","text":"<p>The human proteome is downloaded from UniProt - Reviewed Swiss-Prot. As of Jule 27th, 2024, it has compiled 20435 expert-reviewed human genes that encode proteins. As UniProt sequences in Text format contains information about the sequences, structures,and functions of proteins, users can extract as comprehensive information as possible from the Text file.</p> <p>The following examples show how we use <code>pypropel</code> to achieve this functionality.</p> <pre><code>import pypropel as pp\n\ndf = pp.uniprot.from_text(\n    text_fpn=to('data/uniprot/text/uniprotkb_Human_AND_reviewed_true_AND_m_2023_11_29.txt'),\n    sv_json_fpn=to('data/uniprot/text/human.json'),\n    sv_df_fpn=to('data/uniprot/text/human.txt'),\n)\n</code></pre> <p>The output of the <code>pp.uniprot.from_text</code> function. <pre><code>ID  AC  DE  GN  Ensembl_G_id    Ensembl_T_id    SQ  tms_nums    binding_nums    binding_sites   pdb_nums    pdb_ids pdb_chains  pdb_rezs\nCP2D7_HUMAN A0A087X1C5  RecName: Full=Putative cytochrome P450 2D7 {ECO:0000305}; EC=1.14.14.1 {ECO:0000269|PubMed:15051713};   CYP2D7  NaN     MGLEALVPLAMIVAIFLLLVDLMHRHQRWAARYPPGPLPLPGLGNLLHVDFQNTPYCFDQLRRRFGDVFSLQLAWTPVVVLNGLAAVREAMVTRGEDTADRPPAPIYQVLGFGPRSQGVILSRYGPAWREQRRFSVSTLRNLGLGKKSLEQWVTEEAACLCAAFADQAGRPFRPNGLLDKAVSNVIASLTCGRRFEYDDPRFLRLLDLAQEGLKEESGFLREVLNAVPVLPHIPALAGKVLRFQKAFLTQLDELLTEHRMTWDPAQPPRDLTEAFLAKKEKAKGSPESSFNDENLRIVVGNLFLAGMVTTSTTLAWGLLLMILHLDVQRGRRVSPGCPIVGTHVCPVRVQQEIDDVIGQVRRPEMGDQAHMPCTTAVIHEVQHFGDIVPLGVTHMTSRDIEVQGFRIPKGTTLITNLSSVLKDEAVWKKPFRFHPEHFLDAQGHFVKPEAFLPFSAGRRACLGEPLARMELFLFFTSLLQHFSFSVAAGQPRPSHSRVVSFLVTPSPYELCAVPR 2   1   461 0           \nPIOS1_HUMAN A0A0B4J2F0  RecName: Full=Protein PIGBOS1 {ECO:0000305}; AltName: Full=PIGB opposite strand protein 1 {ECO:0000312|HGNC:HGNC:50696};    PIGBOS1 ENSG00000225973 ENST00000436697.3;ENST00000567948.1 MFRRLTFAQLLFATVLGIAGGVYIFQPVFEQYAKDQKELKEKMQLVQESEEKKS  1   0       0   \nE2F8_HUMAN  A0AVK6  RecName: Full=Transcription factor E2F8; Short=E2F-8;   E2F8    ENSG00000129173 ENST00000250024.9;ENST00000527884.5;ENST00000620009.4   MENEKENLFCEPHKRGLMKTPLKESTTANIVLAEIQPDFGPLTTPTKPKEGSQGEPWTPTANLKMLISAVSPEIRNRDQKRGLFDNRSGLPEAKDCIHEHLSGDEFEKSQPSRKEKSLGLLCHKFLARYPNYPNPAVNNDICLDEVAEELNVERRRIYDIVNVLESLHMVSRLAKNRYTWHGRHNLNKTLGTLKSIGEENKYAEQIMMIKKKEYEQEFDFIKSYSIEDHIIKSNTGPNGHPDMCFVELPGVEFRAASVNSRKDKSLRVMSQKFVMLFLVSTPQIVSLEVAAKILIGEDHVEDLDKSKFKTKIRRLYDIANVLSSLDLIKKVHVTEERGRKPAFKWTGPEISPNTSGSSPVIHFTPSDLEVRRSSKENCAKNLFSTRGKPNFTRHPSLIKLVKSIESDRRKINSAPSSPIKTNKAESSQNSAPFPSKMAQLAAICKMQLEEQSSESRQKVKVQLARSGPCKPVAPLDPPVNAEMELTAPSLIQPLGMVPLIPSPLSSAVPLILPQAPSGPSYAIYLQPTQAHQSVTPPQGLSPTVCTTHSSKATGSKDSTDATTEKAANDTSKASASTRPGSLLPAPERQGAKSRTREPAGERGSKRASMLEDSGSKKKFKEDLKGLENVSATLFPSGYLIPLTQCSSLGAESILSGKENSSALSPNHRIYSSPIAGVIPVTSSELTAVNFPSFHVTPLKLMVSPTSVAAVPVGNSPALASSHPVPIQNPSSAIVNFTLQHLGLISPNVQLSASPGSGIVPVSPRIESVNVAPENAGTQQGRATNYDSPVPGQSQPNGQSVAVTGAQQPVPVTPKGSQLVAESFFRTPGGPTKPTSSSCMDFEGANKTSLGTLFVPQRKLEVSTEDVH 0   0       1   4YO2    A=110-341   3.07\n...\n</code></pre></p> <p>The information extracted is shown as follows.  <pre><code>{\n    'ID': Uniprot ,\n    'AC': Uniprot accession code,\n    'DE': Description,\n    'GN': gene names,\n    'Ensembl_G_id': ensembl gene ID,\n    'Ensembl_T_id': ensembl transcript ID,\n    'SQ': sequence,\n    'tms_nums': number of transmembrane segments,\n    'binding_nums': numbers of binding sites,\n    'binding_sites': PDB IDs of binding sites,\n    'pdb_nums': number of PDB structures,\n    'pdb_ids': IDS of PDB structures,\n    'pdb_chains': IDs of PDB chains,\n    'pdb_rezs': resolutions of PDB structures,\n}\n</code></pre></p> <p>This function will also output a file in <code>json</code> format. It gives specific PDB IDs of the extracted transmembrane segments in <code>tmh_lower</code> and <code>tmh_upper</code>. <pre><code>{\"CP2D7_HUMAN\": {\"pac\": \"A0A087X1C5\", \"gn\": \"CYP2D7\", \"ensembl_id\": \"NaN\", \"binding_num\": 1, \"pdb_num\": 0, \"cyto_lower\": [24], \"cyto_upper\": [301], \"extra_lower\": [1, 323], \"extra_upper\": [2, 515], \"tmh_lower\": [3, 302], \"tmh_upper\": [23, 322], \"nontmh_lower\": [1, 24, 323], \"nontmh_upper\": [2, 301, 515], \"seq\": \"MGLEALVPLAMIVAIFLLLVDLMHRHQRWAARYPPGPLPLPGLGNLLHVDFQNTPYCFDQLRRRFGDVFSLQLAWTPVVVLNGLAAVREAMVTRGEDTADRPPAPIYQVLGFGPRSQGVILSRYGPAWREQRRFSVSTLRNLGLGKKSLEQWVTEEAACLCAAFADQAGRPFRPNGLLDKAVSNVIASLTCGRRFEYDDPRFLRLLDLAQEGLKEESGFLREVLNAVPVLPHIPALAGKVLRFQKAFLTQLDELLTEHRMTWDPAQPPRDLTEAFLAKKEKAKGSPESSFNDENLRIVVGNLFLAGMVTTSTTLAWGLLLMILHLDVQRGRRVSPGCPIVGTHVCPVRVQQEIDDVIGQVRRPEMGDQAHMPCTTAVIHEVQHFGDIVPLGVTHMTSRDIEVQGFRIPKGTTLITNLSSVLKDEAVWKKPFRFHPEHFLDAQGHFVKPEAFLPFSAGRRACLGEPLARMELFLFFTSLLQHFSFSVAAGQPRPSHSRVVSFLVTPSPYELCAVPR\"}, \"PIOS1_HUMAN\": {\"pac\": \"A0A0B4J2F0\", \"gn\": \"PIGBOS1\", \"ensembl_id\": \"ENSG00000225973\", \"binding_num\": 0, \"pdb_num\": 0, \"cyto_lower\": [26], \"cyto_upper\": [54], \"extra_lower\": [], \"extra_upper\": [], \"tmh_lower\": [5], \"tmh_upper\": [25], \"nontmh_lower\": [1, 26], \"nontmh_upper\": [4, 54], \"seq\": \"MFRRLTFAQLLFATVLGIAGGVYIFQPVFEQYAKDQKELKEKMQLVQESEEKKS\"},\n...\n}\n</code></pre></p> <p>Tip</p> <p>The Json file also returns cytoplasmic and extracellular segments of the extracted transmembrane segments, as indicated by <code>cyto_lower</code>, <code>cyto_upper</code>,  <code>extra_lower</code>, and <code>extra_upper</code>.  Their combined segments are non-transmembrane segments (<code>nontmh_lower</code> amd <code>nontmh_upper</code>).</p>"}]}