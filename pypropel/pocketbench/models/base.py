"""
Base model wrapper for PocketBench.

Provides abstract interfaces for wrapping binding site prediction models.
"""

__author__ = "pypropel team"
__version__ = "0.1.0"

from abc import abstractmethod
from typing import List, Optional, Union
from pathlib import Path
import tempfile
import os

from ..core import PBProtein, PBPrediction, PBModel


class PBModelWrapper(PBModel):
    """
    Base wrapper class for external binding site prediction models.
    
    Handles common functionality like:
    - Temporary file management for external tools
    - PDB file writing for models that require files
    - Output parsing to PBPrediction format
    
    Subclasses must implement:
    - name property
    - predict() method
    - _run_inference() for external tools
    """
    
    def __init__(
        self,
        model_path: Optional[Union[str, Path]] = None,
        temp_dir: Optional[Union[str, Path]] = None,
        cleanup: bool = True
    ):
        """
        Initialize model wrapper.
        
        Parameters
        ----------
        model_path : str or Path, optional
            Path to model weights or executable.
        temp_dir : str or Path, optional
            Directory for temporary files. Uses system temp if None.
        cleanup : bool, optional
            Whether to cleanup temporary files. Default True.
        """
        self.model_path = Path(model_path) if model_path else None
        self.temp_dir = Path(temp_dir) if temp_dir else None
        self.cleanup = cleanup
    
    def _get_temp_dir(self) -> Path:
        """Get or create temporary directory."""
        if self.temp_dir:
            self.temp_dir.mkdir(parents=True, exist_ok=True)
            return self.temp_dir
        return Path(tempfile.gettempdir())
    
    def _write_pdb(self, protein: PBProtein, output_path: Path) -> Path:
        """
        Write protein structure to PDB file.
        
        Parameters
        ----------
        protein : PBProtein
            Protein to write.
        output_path : Path
            Output file path.
            
        Returns
        -------
        Path
            Path to written file.
        """
        if protein.full_atoms is not None:
            # Use BioPython to write structure
            try:
                from Bio.PDB import PDBIO
                io = PDBIO()
                io.set_structure(protein.full_atoms)
                io.save(str(output_path))
                return output_path
            except Exception:
                pass
        
        # Fallback: write minimal PDB from coords
        self._write_minimal_pdb(protein, output_path)
        return output_path
    
    def _write_minimal_pdb(self, protein: PBProtein, output_path: Path):
        """Write minimal PDB file from sequence and coordinates."""
        aa_map = {
            'A': 'ALA', 'C': 'CYS', 'D': 'ASP', 'E': 'GLU', 'F': 'PHE',
            'G': 'GLY', 'H': 'HIS', 'I': 'ILE', 'K': 'LYS', 'L': 'LEU',
            'M': 'MET', 'N': 'ASN', 'P': 'PRO', 'Q': 'GLN', 'R': 'ARG',
            'S': 'SER', 'T': 'THR', 'V': 'VAL', 'W': 'TRP', 'Y': 'TYR'
        }
        
        with open(output_path, 'w') as f:
            f.write("HEADER    GENERATED BY POCKETBENCH\n")
            
            for i, (aa, coord) in enumerate(zip(protein.sequence, protein.coords)):
                res_name = aa_map.get(aa, 'ALA')
                atom_num = i + 1
                res_num = i + 1
                x, y, z = coord
                
                # Write CA atom
                line = (
                    f"ATOM  {atom_num:5d}  CA  {res_name} A{res_num:4d}    "
                    f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00           C\n"
                )
                f.write(line)
            
            f.write("END\n")
    
    def _cleanup_temp_files(self, *paths: Path):
        """Remove temporary files if cleanup is enabled."""
        if not self.cleanup:
            return
        
        for path in paths:
            try:
                if path.is_file():
                    path.unlink()
                elif path.is_dir():
                    import shutil
                    shutil.rmtree(path)
            except Exception:
                pass
